;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun linux () (search case "linux" (uname)))
(defun ms-windows () (or (cygwin) (mingw)))
(defun mac-osx () (darwin))
(defun cygwin () (search case "cygwin" (uname)))
(defun mingw () (search case "mingw" (uname)))
(defun darwin () (search case "darwin" (uname)))
(defun raspberry () (search case "linux arm" (uname)))

(defun clinux () (search case "linux" (cuname)))
(defun cms-windows () (or (ccygwin) (cmingw)))
(defun cmac-osx () (cdarwin))
(defun ccygwin () (search case "cygwin" (cuname)))
(defun cmingw () (search case "mingw" (cuname)))
(defun cdarwin () (search case "darwin" (cuname)))
(defun craspberry () (search case "linux arm" (cuname)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun gcry-md5sum (obj) (gcry-md-hash (cmacro GCRY_MD_MD5) obj))
(defun gcry-sha1sum (obj) (gcry-md-hash (cmacro GCRY_MD_SHA1) obj))
(defun gcry-sha256sum (obj) (gcry-md-hash (cmacro GCRY_MD_SHA256) obj))
(defun gcry-md5sum-fast (obj) (gcry-md-hash-fast (cmacro GCRY_MD_MD5) obj))
(defun gcry-sha1sum-fast (obj) (gcry-md-hash-fast (cmacro GCRY_MD_SHA1) obj))
(defun gcry-sha256sum-fast (obj) (gcry-md-hash-fast (cmacro GCRY_MD_SHA256) obj))
(defun gcry-fmd5sum (path) (gcry-md-hash-file (cmacro GCRY_MD_MD5) path))
(defun gcry-fsha1sum (path) (gcry-md-hash-file (cmacro GCRY_MD_SHA1) path))
(defun gcry-fsha256sum (path) (gcry-md-hash-file (cmacro GCRY_MD_SHA256) path))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; (nextprime n)
;;; il più piccolo primo maggiore di n, tuttavia:
;;; - potrebbe non essere primo
;;; - potrebbe non essere il più piccolo
;;;
;;; (nextprime-secure n)
;;; il più piccolo primo maggiore di n (garantito)
;;;
;;; (nextprime-secure-fast n)
;;; il più piccolo primo maggiore di n, tuttavia:
;;; - è primo garantito
;;; - potrebbe non essere il più piccolo
;;;
;;; Note:
;;; - nextprime è il test di primalità di Miller-Rabin
;;; - isprime è il test AKS

(defun nextprime-secure (n) net nextprime-secure)
(defnet nextprime-secure (n @n)
        (set @n n)
        (repeat (inc @n)
                until (isprime @n) ))

(defun nextprime-secure-fast (n) net nextprime-secure-fast)
(defnet nextprime-secure-fast (n @n)
        (set @n n)
        (repeat (set @n (nextprime @n))
                until (isprime @n) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun colorp (c) (integerp (pix-color-red c)))

(defun black ()      (pix-color 0x00 0x00 0x00))
(defun white ()      (pix-color 0xff 0xff 0xff))
(defun red ()        (pix-color 0xff 0x00 0x00))
(defun green ()      (pix-color 0x00 0xff 0x00))
(defun blue ()       (pix-color 0x00 0x00 0xff))
(defun darkgreen ()  (pix-color 0x1a 0x83 0x2b))
(defun purple ()     (pix-color 0xff 0x00 0xff))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet invert-test (net param)
        (deflocal i)

        (alt    (seq    (call net param)
                        (set i true) )
                (set i false) )
        (not i) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cal->joule (x) (* x 4.184))
(defun joule->cal (x) (/ x 4.184))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;
;;; restituisce, se lo trova, un path esistente che matcha a destra l`input
;;; cercandolo in alcune directory `standard`
;;;

(defun search-default-path (path) net search-default-path)
(defnet search-default-path (path @path)
        (deflocal found checked p i)

        (if (not (stringp path))
        then    (set path (sprint path)) )
        (<> path "")
        (if (lmatch path "/" ".")
        then    (set @path path)
                (set found (pathexists @path))
        else    (set checked (assoc))
                (for p in (list (cwd) (homepath "wd/programming/treep/trp") (homepath ".treep")) do
                        (if (not (rmatch p "/"))
                        then    (inc p "/") )
                        (repeat (search "/" p i (maxint))
                                (set p (sub 0 i p))
                                (for i in [ "" "/common" "/icons" "/common/icons" ] do
                                        (set @path (+ p i "/" path))
                                        (if (= <checked @path> undef)
                                        then    (set <checked @path> true)
                                                (set found (pathexists @path)) )
                                        until found )
                                until found
                                until (= p "") )
                        until found ))
        (truep found) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet filesystem-visit (path cback udata)
        (filesystem-visit-basic 0 (maxint) path cback udata) )

(defnet filesystem-visit-basic (level max-level path cback udata)
        (deflocal c e p r d)

        (set c (if (rmatch path "/") "" "/"))
        (set r (array 0))
        (if (< level max-level)
        then    (set d (array 0)) )
        (for e in (directory path) do
                (if (not (in e [ "." ".." ]))
                then    (set p (+ path c e))
                        (if (isreg p)
                        then    (array-append r (cons p e))
                        else    (if (and (isdir p) (< level max-level))
                                then    (array-append d e) ))))
        (sort r (funptr lesscdr))
        (for e in r do
                (call cback (car e) (cdr e) udata) )
        (if (< level max-level)
        then    (sort d)
                (inc level)
                (for e in d do
                        (filesystem-visit-basic level max-level (+ path c e) cback udata) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet search-and-cut (key @s @cut)
        (deflocal i)

        (search key @s i)
        (set @cut (sub 0 i @s))
        (set @s (sub (+ i (length key)) (maxint) @s)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun find-and-replace (str from to) net find-and-replace-low)

(defnet find-and-replace (@str from to)
        (find-and-replace-low @str from to @str) )

(defnet find-and-replace-low (str from to @res)
        (deflocal i)

        (set @res "")
        (opt*   (search from str i)
                (inc @res (sub 0 i str) to)
                (set str (sub (+ i (length from)) (maxint) str)) )
        (inc @res str) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun trim-trn (s)
        (rtrim (ltrim s ' ' '\t' '\r' '\n') ' ' '\t' '\r' '\n') )

(defnet trim-trn (@s)
        (ltrim @s ' ' '\t' '\r' '\n')
        (rtrim @s ' ' '\t' '\r' '\n') )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun str-remove-blanks (str) net str-remove-blanks-low)

(defnet str-remove-blanks (@str)
        (str-remove-blanks-low @str @str) )

(defnet str-remove-blanks-low (str @str)
        (deflocal i)

        (ltrim str ' ' '\t' '\000')
        (rtrim str ' ' '\t' '\000')
        (find-and-replace-low str "\t" " " str)
        (find-and-replace-low str "\000" " " str)
        (set @str "")
        (opt*   (search "  " str i)
                (inc @str (sub 0 (+ i 1) str))
                (set str (ltrim (sub (+ i 2) (maxint) str))) )
        (inc @str str) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet str-readline (@str @l)
        (deflocal i)

        (alt    (seq    (search "\n" @str i)
                        (set @l (sub 0 i @str))
                        (not (search "\r" @l))
                        (set @str (sub (+ i 1) (maxint) @str))
                        (opt (lmatch remove @str "\r")) )
                (seq    (search "\r" @str i)
                        (set @l (sub 0 i @str))
                        (set @str (sub (+ i 1) (maxint) @str))
                        (opt (lmatch remove @str "\n")) )
                (if (or (= @str "") (not (stringp @str)))
                then    (clr @l)
                else    (set @l @str)
                        (set @str "") )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun str->array (str) net str->array)
(defnet str->array (str @a)
        (deflocal i)

        (str-remove-blanks-low str str)
        (set @a (array 0))
        (opt*   (search " " str i)
                (array-append @a (sub 0 i str))
                (set str (sub (+ i 1) (maxint) str)) )
        (array-append @a str) )

(defun str->array-explode (str) net str->array-explode)
(defnet str->array-explode (str @a)
        (deflocal i)

        (set @a (array (length str)))
        (for i in str do
                (set <@a (for-pos)> i) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path->lines (path) net path->lines)
(defnet path->lines (path @a) (path->lines-low path @a false))

(defun path->lines-clean (path) net path->lines-clean)
(defnet path->lines-clean (path @a) (path->lines-low path @a true))

(defnet path->lines-low (path @a clean)
        (deflocal f l)

        (set f (fopenro path))
        (<> f undef)
        (set @a (array 0))
        (repeat (set l (freadline f))
                until (= l undef)
                (if clean
                then    (ltrim l ' ' '\t')
                        (rtrim l ' ' '\t') )
                (array-append @a l) )
        (close f) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun array-copy (a) net array-copy)
(defnet array-copy (a @a)
        (deflocal n i)

        (set n (length a))
        (set @a (array n))
        (for i in 0 .. (- n 1) do
                (set <@a i> <a i>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun smart-min (s1 s2) net smart-min)
(defnet smart-min (s1 s2 @res)
        (deflocal n v1 v2)

        (set n (max-prefix-case s1 s2))
        (set s1 (sub n (maxint) s1))
        (set s2 (sub n (maxint) s2))
        (set n (max-suffix-case s1 s2))
        (set s1 (+ "1" (sub 0 (- (length s1) n) s1) "0"))
        (set s2 (+ "1" (sub 0 (- (length s2) n) s2) "0"))
        (set v1 (str->num s1))
        (set v2 (str->num s2))
        (if (and (<> v1 undef) (<> v2 undef))
        then    (set @res (< v1 v2))
        else    (set @res (< s1 s2)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun str-succ (s) (str-succ0 (rtrim s '\377') s))
(defun str-succ0 (s ss)
        (if (= s "") (+ ss '\001')
                (str-succ1 s (- (length s) 1)) ))
(defun str-succ1 (s l)
        (+ (sub 0 l s) (+ <s l> 1)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun str-capitalize (s) net str-capitalize)
(defnet str-capitalize (s @s)
        (deflocal i t)

        (set @s "")
        (opt*   (search " " s i)
                (inc i)
                (set t (sub 0 i s))
                (set s (sub i (maxint) s))
                (inc @s (utf8-toupper (sub 0 1 t)) (sub 1 (maxint) t)) )
        (if (<> s "")
        then    (inc @s (utf8-toupper (sub 0 1 s)) (sub 1 (maxint) s)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun str-ellipsize-middle (str maxlen)
        (str-ellipsize-middle-a str (length str) maxlen) )

(defun str-ellipsize-middle-a (str len maxlen)
        (if (<= len maxlen) str
                (str-ellipsize-middle-b str len (/ (- maxlen 1) 2)) ))

(defun str-ellipsize-middle-b (str len clen)
        (+ (sub 0 (ceil clen) str)
           "\342\200\246"
           (sub (- len (floor clen)) (maxint) str) ))

(defun str-ellipsize-start (str maxlen)
        (str-ellipsize-start-a str (length str) maxlen) )

(defun str-ellipsize-start-a (str len maxlen)
        (if (<= len maxlen) str
                (+ (sub 0 (- maxlen 1) str) "\342\200\246") ))

(defun str-ellipsize-end (str maxlen)
        (str-ellipsize-end-a str (length str) maxlen) )

(defun str-ellipsize-end-a (str len maxlen)
        (if (<= len maxlen) str
                (+ "\342\200\246" (sub (- len maxlen -1) (maxint) str)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun str-split (str len) net str-split)
(defnet str-split (str len @str)
        (deflocal i)

        (if (<= (length str) len)
        then    (set @str str)
        else    (set i (sub 0 (+ len 1) str))
                (alt    (seq    (search "\n" i i)
                                (inc i)
                                (set @str (sub 0 i str))
                                (set str (sub i (maxint) str)) )
                        (seq    (search " " i i (maxint))
                                (set @str (+ (sub 0 i str) nl))
                                (set str (sub (+ i 1) (maxint) str)) )
                        (seq    (set @str (+ (sub 0 len str) nl))
                                (set str (sub len (maxint) str)) ))
                (inc @str (str-split str len)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet str-save (path s)
        (deflocal f)

        (set f (fcreate path))
        (<> f undef)
        (fprint f s)
        (close f) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet raw-save (path raw)
        (deflocal f i j)

        (set f (fcreate path))
        (<> f undef)
        (set i (length raw))
        (set j (raw-write raw f i))
        (close f)
        (= i j) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun utf8-bom ()
        (+ "" (int->char 0xef) (int->char 0xbb) (int->char 0xbf)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun utf8p (s) (integerp (utf8-length s)))
(defnet utf8p (s) (integerp (utf8-length s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun utf8-validate (str)
        (if (stringp str)
                (utf8-validate0 (rtrim (ltrim str ' ' '\t' '\000') ' ' '\t' '\000'))
                str ))
(defun utf8-validate0 (str)
        (if (utf8p str) str (iso->utf8 str)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun pathquote (path) net pathquote)
(defnet pathquote (path @qpath)
        (deflocal l c)
        (set l (queue))
        (for c in path do
                (if (not (or (in c 'a' .. 'z')
                             (in c 'A' .. 'Z')
                             (in c '0' .. '9')
                             (in c [ '.' '+' '-' '_' '=' ] ) ))
                then    (queue-put l '\\') )
                (queue-put l c) )
        (set @qpath (implode l)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-legalize (path) net path-legalize)
(defnet path-legalize (path @qpath)
        (deflocal l c)
        (set l (queue))
        (for c in path do
                (if (in c [ '!' '?' '*' '\\' '/' ])
                then    (set c '-') )
                (queue-put l c) )
        (set @qpath (implode l)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun fullpath->name (path) net fullpath->name)
(defnet fullpath->name (path @name)
        (deflocal i)
        (alt    (seq    (search "/" path i (maxint))
                        (set @name (sub (+ i 1) (maxint) path)) )
                (set @name path) ))

(defun fullpath->dir (path) net fullpath->dir)
(defnet fullpath->dir (path @dir)
        (rmatch remove path (fullpath->name path))
        (rtrim path '/')
        (set @dir path) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet paths-have-the-same-size (path1 path2)
        (deflocal size)

        (paths-have-the-same-size-low path1 path2 size) )

(defnet paths-have-the-same-size-low (path1 path2 @size)
        (set @size (fsize path1))
        (integerp @size)
        (>= @size 0)
        (= @size (fsize path2)) )

(defun paths-have-the-same-size (path1 path2) net paths-have-the-same-size-net)
(defnet paths-have-the-same-size-net (path1 path2 @res)
        (alt    (seq    (paths-have-the-same-size path1 path2)
                        (set @res true) )
                (set @res false) ))

(defnet paths-have-the-same-content (path1 path2 @samesize @dbit @dbyt)
        (deflocal rem f1 f2 raw1 raw2 c1 c2 i j k)

        (alt    (seq    (paths-have-the-same-size-low path1 path2 rem)
                        (set f1 (fopenro path1))
                        (<> f1 undef)
                        (set f2 (fopenro path2))
                        (if (= f2 undef)
                        then    (close f1)
                                (fail) )
                        (set raw1 (raw 65536))
                        (set raw2 (raw 65536))
                        (set @dbit 0)
                        (set @dbyt 0)
                        (opt*   (> rem 0)
                                (set i (raw-read raw1 f1))
                                (= i (raw-read raw2 f2))
                                (dec rem i)
                                (if (<> raw1 raw2)
                                then    (for j in 1 .. i do
                                                (set c1 <raw1 (for-pos)>)
                                                (set c2 <raw2 (for-pos)>)
                                                (if (<> c1 c2)
                                                then    (inc @dbyt)
                                                        (set c1 (length c1))
                                                        (set c2 (length c2))
                                                        (for k in 1 .. 8 do
                                                                (if (<> (% c1 2) (% c2 2))
                                                                then    (inc @dbit) )
                                                                (set c1 (div c1 2))
                                                                (set c2 (div c2 2)) )))))
                        (close raw1 raw2 f1 f2)
                        (set @samesize true) )
                (seq    (set @samesize false)
                        (clr @dbit @dbyt) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet path-content-is-valid (path)
        (deflocal fail ext)

        (set fail false)
        (set ext (path-suggest-extension path))
        (alt    (seq    (in ext [ "rar" "cbr" ])
                        (alt    (path-content-is-valid-rar path)
                                (set fail true) ))
                (seq    (in ext [ "zip" "cbz" "epub" "odt" "docx" "apk" ])
                        (alt    (path-content-is-valid-zip path)
                                (set fail true) ))
                (seq    (in ext [ "xz" ])
                        (alt    (path-content-is-valid-xz path)
                                (set fail true) ))
                (seq    (in ext [ "flac" ])
                        (alt    (path-content-is-valid-flac path)
                                (set fail true) ))
                (seq    (in ext [ "wv" ])
                        (alt    (path-content-is-valid-wv path)
                                (set fail true) ))
                (seq    (in ext [ "avi" "mkv" "mp4" "flv" "ape" ])
                        (alt    (path-content-is-valid-ffmpeg path)
                                (set fail true) ))
                (seq    (in ext [ "jpg" ])
                        (alt    (path-content-is-valid-jpg path)
                                (set fail true) ))
                (seq    (in ext [ "png" ])
                        (alt    (path-content-is-valid-png path)
                                (set fail true) ))
                (seq    (in ext [ "pdf" ])
                        (alt    (path-content-is-valid-pdf path)
                                (set fail true) ))
                (set fail true) )
        (not fail) )

(defnet path-content-is-valid-rar (path)
        (system "rar t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-zip (path)
        (system "7z t " (pathquote path) " >/dev/null 2>/dev/null") )
 
(defnet path-content-is-valid-xz (path)
        (system "xz -t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-flac (path)
        (system "flac -t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-wv (path)
        (system "wvunpack " (pathquote path) " -o -" " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-ffmpeg (path)
        (deflocal valid tmp tmppath)

        (set valid false)
        (mktmpdir tmp)
        (opt    (set tmppath (+ tmp "/a"))
                (system "ffmpeg -v 24 -i " (pathquote path) " -f null - >/dev/null 2>" tmppath) ; 16=errori 24=errori+warnings
                (= (fsize tmppath) 0)
                (set valid true) )
        (rmhier tmp)
        (truep valid) )

(defnet path-content-is-valid-jpg (path)
        (system "djpeg " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-png (path)
        (system "png2pnm " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-pdf (path)
        (search "Status: Well-Formed and valid"
                (system-stdout->str (homepath (+ "jhove/jhove -m pdf-hul "
                                                 (pathquote path) )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-is-zip-type-low (path files) net path-is-zip-type-low)
(defnet path-is-zip-type-low (path files @res)
        (deflocal tmp p)
        (mktmpdir tmp)
        (alt    (seq    (pathexists path)
                        (set path (realpath path))
                        (system "cd " (pathquote tmp) " && unzip " (pathquote path) " >/dev/null 2>/dev/null")
                        (for p in files do
                                (pathexists (+ tmp "/" p)) )
                        (set @res true) )
                (set @res false) )
        (rmhier tmp) )

(defun path-is-docx (path)
        (path-is-zip-type-low path
                [ "[Content_Types].xml"
                  "_rels/.rels"
                  "word/document.xml" ] ))

(defun path-is-xps (path)
        (path-is-zip-type-low path
                [ "[Content_Types].xml"
                  "FixedDocSeq.fdseq"
                  "_rels/.rels"
                  "Documents/1" ] ))

(defun path-is-odt (path)
        (path-is-zip-type-low path
                [ "content.xml"
                  "mimetype"
                  "settings.xml"
                  "styles.xml"
                  "META-INF/manifest.xml" ] ))

(defun path-is-epub (path) net path-is-epub)
(defnet path-is-epub (path @res)
        (deflocal tmp p)
        (mktmpdir tmp)
        (alt    (seq    (pathexists path)
                        (set path (realpath path))
                        (system "cd " (pathquote tmp) " && unzip " (pathquote path) " >/dev/null 2>/dev/null")
                        (pathexists (+ tmp "/META-INF/container.xml"))
                        (set p (str-load (+ tmp "/mimetype")))
                        (stringp p)
                        (lmatch p "application/epub+zip")
                        (set @res true) )
                (set @res false) )
        (rmhier tmp) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-suggest-extension (path) net path-suggest-extension)
(defnet path-suggest-extension (path @ext)
        (deflocal m)
        (set m (magic-file path))
        (stringp m)
        (alt    (seq    (= "TreeP source code text" m)
                        (alt    (path-suggest-extension-permissive path [ "tin" ] @ext)
                                (set @ext "trp") ))
                (seq    (search case "Perl script" m)
                        (set @ext "pl") )
                (seq    (search case "Web Open Font Format (Version 2)" m)
                        (set @ext "woff2") )
                (seq    (search case "Web Open Font Format" m)
                        (set @ext "woff") )
                (seq    (search case "Spline Font Database" m)
                        (set @ext "sfd") )
                (seq    (search case "Embedded OpenType (EOT)" m)
                        (set @ext "eot") )
                (seq    (search case "TrueType Font data" m)
                        (set @ext "ttf") )
                (seq    (search case "Netpbm image data" m)
                        (alt    (seq    (search case "pixmap" m)
                                        (set @ext "ppm") )
                                (seq    (search case "greymap" m)
                                        (set @ext "pgm") )
                                (seq    (search case "bitmap" m)
                                        (set @ext "pbm") )))
                (seq    (search case "JPEG image data" m)
                        (set @ext "jpg") )
                (seq    (search case "DICOM medical imaging data" m)
                        (set @ext "dic") )
                (seq    (search case "JPEG 2000" m)
                        (set @ext "jp2") )
                (seq    (search case "Web/P image" m)
                        (set @ext "webp") )
                (seq    (search case "X pixmap image" m)
                        (search case "ASCII text" m)
                        (set @ext "xpm") )
                (seq    (search case "PNG image" m)
                        (set @ext "png") )
                (seq    (search case "GIF image data" m)
                        (set @ext "gif") )
                (seq    (search case "PC bitmap" m)
                        (search case "Windows " m)
                        (set @ext "bmp") )
                (seq    (search case "TIFF image data" m)
                        (set @ext "tif") )
                (seq    (search case "MPEG transport stream data" m)
                        (set @ext "ts") )
                (seq    (search case "MPEG sequence" m)
                        (alt    (seq    (search case "program multiplex" m)
                                        (search case ", v2," m)
                                        (path-suggest-extension-permissive path [ "VOB" "sub" ] @ext) )
                                (seq    (search case "Y'CbCr 4:2:0 video" m)
                                        (alt    (seq    (search case ", v1," m)
                                                        (set @ext "m1v") )
                                                (seq    (search case ", v2," m)
                                                        (set @ext "m2v") )))
                                (set @ext "mpg") ))
                (seq    (search case "Windows Television DVR Media" m)
                        (set @ext "wtv") )
                (seq    (search case "Apple QuickTime movie" m)
                        (set @ext "mov") )
                (seq    (search case "ISO Media" m)
                        (alt    (path-suggest-extension-permissive path [ "mov" "3gp" "m4a" ] @ext)
                                (set @ext "mp4") ))
                (seq    (search case "RIFF (little-endian) data" m)
                        (alt    (seq    (search "WAVE audio" m)
                                        (set @ext "wav") )
                                (seq    (search "AVI" m)
                                        (set @ext "avi") )
                                (seq    (search "wrapped MPEG" m)
                                        (set @ext "mpg") )))
                (seq    (search case "Microsoft ASF" m)
                        (alt    (path-suggest-extension-permissive path [ "wma" ] @ext)
                                (set @ext "wmv") ))
                (seq    (search case "RealMedia file" m)
                        (alt    (path-suggest-extension-permissive path [ "ra" ] @ext)
                                (set @ext "rm") ))
                (seq    (search case "Matroska data" m)
                        (alt    (path-suggest-extension-permissive path [ "mka" "webm" ] @ext)
                                (set @ext "mkv") ))
                (seq    (search case "WebM" m)
                        (set @ext "webm") )
                (seq    (search case "Ogg data" m)
                        (alt    (seq    (or (search case "Theora video" m)
                                            (search case "Skeleton" m) )
                                        (set @ext "ogv") )
                                (seq    (search case "ogm video" m)
                                        (set @ext "ogm") )
                                (seq    (search case "audio" m)
                                        (alt    (path-suggest-extension-permissive path [ "spx" ] @ext)
                                                (set @ext "ogg") ))))
                (seq    (search case "Macromedia Flash Video" m)
                        (set @ext "flv") )
                (seq    (search case "Macromedia Flash Data" m)
                        (set @ext "swf") )
                (seq    (search case "MPEG ADTS" m)
                        (alt    (seq    (search case "AAC" m)
                                        (set @ext "aac") )
                                (seq    (search case " layer III" m)
                                        (set @ext "mp3") )
                                (seq    (search case " layer II" m)
                                        (set @ext "mp2") )))
                (seq    (search case "Audio file with ID3" m)
                        (path-suggest-extension-permissive path [ "mp3" ] @ext) )
                (seq    (search case "ATSC A/52" m)
                        (set @ext "ac3") )
                (seq    (search case "FLAC audio bitstream data" m)
                        (set @ext "flac") )
                (seq    (search case "Monkey's Audio compressed format" m)
                        (set @ext "ape") )
                (seq    (search case "WavPack Lossless Audio" m)
                        (set @ext "wv") )
                (seq    (search case "Java archive data" m)
                        (set @ext "jar") )
                (seq    (alt    (lmatch case m "tar archive")
                                (search case " tar archive" m)
                                (search case "\ntar archive" m) )
                        (set @ext "tar") )
                (seq    (search case "RAR archive data" m)
                        (alt    (seq    (path-suggest-extension-permissive path [ "cbr" "cbz" ] @ext)
                                        (if (= @ext "cbz")
                                        then    (set @ext "cbr") ))
                                (set @ext "rar") ))
                (seq    (search case "7-zip archive data" m)
                        (set @ext "7z") )
                (seq    (alt    (search case "Zip archive data" m)
                                (search case "Zip data" m) )
                        (alt    (seq    (path-suggest-extension-permissive path [ "cbr" "cbz" "jar" "epub" "docx" "odt" "ods" "xps" "htmlz" "xlsx" "apk" ] @ext)
                                        (if (= @ext "cbr")
                                        then    (set @ext "cbz") ))
                                (set @ext "zip") ))
                (seq    (search case "gzip compressed data" m)
                        (alt    (path-suggest-extension-permissive path [ "tgz" ] @ext)
                                (set @ext "gz") ))
                (seq    (search case "brotli compressed data" m)
                        (set @ext "br") )
                (seq    (search case "bzip2 compressed data" m)
                        (set @ext "bz2") )
                (seq    (search case "XZ compressed data" m)
                        (set @ext "xz") )
                (seq    (search case "lzip compressed data" m)
                        (set @ext "lz") )
                (seq    (search case "compress'd data 16 bits" m)
                        (set @ext "Z") )
                (seq    (search case "Debian binary package" m)
                        (set @ext "deb") )
                (seq    (search case "RPM " m)
                        (search case " bin " m)
                        (set @ext "rpm") )
                (seq    (search case "cpio archive" m)
                        (set @ext "cpio") )
                (seq    (search case "current ar archive" m)
                        (path-suggest-extension-permissive path [ "a" ] @ext) )
                (seq    (search case "BitTorrent file" m)
                        (set @ext "torrent") )
                (seq    (search case "Microsoft Reader eBook Data" m)
                        (set @ext "lit") )
                (seq    (search case "EPUB document" m)
                        (set @ext "epub") )
                (seq    (search case "Mobipocket E-book" m)
                        (alt    (path-suggest-extension-permissive path [ "azw" "azw3" "azw4" "mobi" "prc" ] @ext)
                                (set @ext "mobi") ))
                (seq    (search case "PostScript document text" m)
                        (set @ext "ps") )
                (seq    (search case "PDF document" m)
                        (set @ext "pdf") )
                (seq    (search "DjVu" m)
                        (or     (search case "multiple page document" m)
                                (search case "single page document" m) )
                        (set @ext "djvu") )
                (seq    (search case "MS Windows HtmlHelp Data" m)
                        (set @ext "chm") )
                (seq    (search case "TeX DVI file" m)
                        (set @ext "dvi") )
                (seq    (search case "OpenDocument Text" m)
                        (set @ext "odt") )
                (seq    (search case "OpenDocument Spreadsheet" m)
                        (set @ext "ods") )
                (seq    (search case "Rich Text Format data" m)
                        (set @ext "rtf") )
                (seq    (search case "CDFV2 Microsoft Word" m)
                        (set @ext "doc") )
                (seq    (alt    (search case "CDF V2 Document" m)
                                (search case "Document File V2 Document" m) )
                        (path-suggest-extension-permissive path [ "doc" "ppt" ] @ext) )
                (seq    (alt    (search case "CDFV2 Microsoft Excel" m)
                                (search case "Composite Document File V2 Document" m) )
                        (path-suggest-extension-permissive path [ "xls" ] @ext) )
                (seq    (search case "HTML" m)
                        (search case "document" m)
                        (search case "text" m)
                        (path-suggest-extension-permissive path [ "htm" "html" "xls" ] @ext)
                        (if (= @ext "htm")
                        then    (set @ext "html") ))
                (seq    (search case "XML" m)
                        (search case "document" m)
                        (search case "text" m)
                        (alt    (path-suggest-extension-permissive path [ "svg" ] @ext)
                                (set @ext "xml") ))
                (seq    (search case "lyx " m)
                        (search case "text" m)
                        (set @ext "lyx") )
                (seq    (search case "SQLite" m)
                        (alt    (path-suggest-extension-permissive path [ "cfg" ] @ext)
                                (set @ext "db") ))
                (seq    (search case "ext2 filesystem data" m)
                        (set @ext "ext2") )
                (seq    (search case "ISO 9660 CD-ROM filesystem data" m)
                        (set @ext "iso") )
                (seq    (search case "UDF filesystem data" m)
                        (set @ext "iso") )
                (seq    (search case "PE32 executable" m)
                        (search case "MS Windows" m)
                        (alt    (seq    (search case "(dll)" m)
                                        (set @ext "dll") )
                                (set @ext "exe") ))
              ;  (seq    (search case "lisp/scheme" m)
              ;          (alt    (path-suggest-extension-permissive path [ "l" "ss" ] @ext)
              ;                  (set @ext "l") ))
                (seq    (search case " text" m)
                        (alt    (seq    (= (path-extension path) "")
                                        (set @ext "") )
                                (path-suggest-extension-permissive path
                                        [ "txt" "cue" "log" "srt" "bat" "avs" "mfl" "opf" "pgn" "fen" "c" "h" "cpp" "cc" "pas" "hs" "go" "clp" "l" "ss" ] @ext )))))

(defnet path-suggest-extension-permissive (path ext-l @ext)
        (deflocal found)
        (set found false)
        (for @ext in ext-l do
                (set found (rmatch case path (+ "." @ext)))
                until found )
        (truep found) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-extension (path) net path-extension)
(defnet path-extension (path @ext)
        (deflocal i)
        (set @ext "")
        (opt    (search "." path i (maxint))
                (> i 0)
                (<> <path (- i 1)> '/')
                (set @ext (sub (+ i 1) (maxint) path))
                (not (search "/" @ext)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-change-extension (path new-ext) (path-change-extension-basic false path new-ext))
(defun path-change-extension-overwrite (path new-ext) (path-change-extension-basic true path new-ext))
(defun path-change-extension-basic (overwrite path new-ext) net path-change-extension-basic)
(defnet path-change-extension-basic (overwrite path new-ext @path)
        (deflocal ext)
        (set @path path)
        (set ext (path-extension @path))
        (if (and (= new-ext ext) (not overwrite))
        then    (set @path (+ @path "." ext))
        else    (rmatch remove @path ext)
                (set @path (+ @path (if (rmatch @path ".") "" ".") new-ext)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-find-by-extension-basic (max-level path ext) net path-find-by-extension-basic)
(defnet path-find-by-extension-basic (max-level path ext @path)
        (deflocal a)

        (rtrim path '/')
        (truep (isdir path))
        (set a (array 2))
        (set <a 0> ext)
        (set <a 1> nil)
        (filesystem-visit-basic 0 max-level path (netptr path-find-by-extension-cback) a)
        (<> <a 1> nil)
        (set @path <<a 1> 0>) )

(defnet path-find-by-extension-cback (path name a)
        (if (= (path-extension path) <a 0>)
        then    (set <a 1> (cons path <a 1>)) ))

(defun path-find-by-extension (path ext) (path-find-by-extension-basic 0 path ext))
(defun path-find-by-extension-rec (path ext) (path-find-by-extension-basic (maxint) path ext))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-truncate (path maxlen) net path-truncate)
(defnet path-truncate (path maxlen @path)
        (deflocal e)
        (set @path path)
        (set e (path-extension @path))
        (rmatch remove @path e)
        (opt    (rmatch remove @path ".")
                (set e (+ "." e)) )
        (if (>= (length e) maxlen)
        then    (set @path path)
                (set e "") )
        (set @path (+ (sub 0 (- maxlen (length e)) @path) e)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun hexdigit (n) (if (= n undef) ' ' (hexdigit0 (% n 0x10))))
(defun hexdigit0 (n)
        (if (< n 10) (+ '0' n) (+ 'a' (- n 10))) )

(defun charhex2int (c)
        (if (in c '0' .. '9') (- (length c) 48)
        (if (in c 'A' .. 'F') (- (length c) 55)
        (if (in c 'a' .. 'f') (- (length c) 87)
        undef ))))

(defun int->hex (n) (sprintl (cons "0x" (int->hex0 n nil))))
(defun int->hex0 (n l)
        (if (= n 0) (if (= l nil) [ 0 ] l)
                (int->hex0 (div n 16) (cons (hexdigit n) l)) ))

(defun hex->int (s) net hex->int)
(defnet hex->int (s @n)
        (opt (lmatch remove s "0x"))
        (set @n 0)
        (repeat until (= s "")
                (set @n (+ (* @n 16) (charhex2int <s 0>)))
                (set s (sub 1 (maxint) s)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun unhex-path (path) net unhex-path)
(defnet unhex-path (path @path)
        (deflocal i)

        (alt    (seq    (search "%" path i)
                        (set @path (+ (sub 0 i path)
                                      (int->char (hex->int (sub (+ i 1) 2 path)))
                                      (unhex-path (sub (+ i 3) (maxint) path)) )))
                (set @path path) ))

(defun adjust-path (path)
        (if (cmingw)
                (find-and-replace (unhex-path path) "\\" "/")
                (unhex-path path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun relative-difference (x y)
        (/ (abs (- x y)) 0.5 (+ x y)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun date-trunc (date) (date-trunc0
        (date-year date) (date-month date) (date-day date) ))
(defun date-trunc0 (y m d)
        (if (<> d undef)  (date y m d)
        (if (<> m undef)  (date y m)
                          (date y) )))
(defun date-trunc-hhmmss (date) (date-trunc1
        (date-year date) (date-month date) (date-day date)
        (date-hours date) (date-minutes date) (date-seconds date) ))
(defun date-trunc1 (y m d hh mm ss)
        (if (<> ss undef) (date y m d hh mm ss)
        (if (<> mm undef) (date y m d hh mm)
        (if (<> hh undef) (date y m d hh)
        (if (<> d  undef) (date y m d)
        (if (<> m  undef) (date y m)
                          (date y) ))))))

(defun now-hhmmss () (date-trunc-hhmmss (now)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun date-last-of-year (d) (date (date-year d) 12 31))

(defun date-last-of-month (d) net date-last-of-month)
(defnet date-last-of-month (d @d)
        (deflocal y m)

        (set y (date-year d))
        (set m (date-month d))
        (if (< m 12)
        then    (inc m)
        else    (set m 1)
                (inc y) )
        (set @d (- (date y m 1) 86400)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun year-max-less-or-equal (date day month) net year-max-less-or-equal)
(defnet year-max-less-or-equal (date day month @year)
        (set @year (date-year date))
        (if (or (< (date-month date) month)
                (and (= (date-month date) month) (< (date-day date) day)) )
        then    (dec @year) ))

(defun year-min-greater (date day month) net year-min-greater)
(defnet year-min-greater (date day month @year)
        (set @year (date-year date))
        (if (or (> (date-month date) month)
                (and (= (date-month date) month) (>= (date-day date) day)) )
        then    (inc @year) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet match-case (s1 s2)
        (lmatch case remove s1 s2)
        (= s1 "") )

(defun match-case (s1 s2) net match-case-low)
(defnet match-case-low (s1 s2 @res)
        (alt    (seq    (match-case s1 s2)
                        (set @res true) )
                (set @res false) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun format-num (x) net format-num)
(defnet format-num (x @s)
        (deflocal minus y)

        (if (< x 0)
        then    (set x -x)
                (set minus true)
        else    (set minus false) )
        (if (< x 1000)
        then    (set @s (sprint x))
        else    (set y (div (floor x) 1000))
                (dec x (* y 1000))
                (set @s (+ (format-num y) ","
                           (if (< x 100) (if (< x 10) "00" "0") "")
                           x )))
        (if minus
        then    (set @s (+ "-" @s)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun date->str (d)
        (sprint (date-year d)
                (date->str0 (date-month d))
                (date->str0 (date-day d))
                (date->str0 (date-hours d))
                (date->str0 (date-minutes d))
                (date->str0 (date-seconds d)) ))
(defun date->str0 (v)
        (if (= v undef) ""
                (sprint (if (< v 10) '0' "") v) ))

(defun str->date (s) net str->date)
(defnet str->date (s @d)
        (alt    (str->date1 s @d)
                (str->date2 s @d) ))

(defnet str->date1 (s @d)
        (case (length s) of
                4       (set @d (date (str->num s)))
                6       (set @d (date (str->num (sub  0 4 s))
                                      (str->num (sub  4 2 s)) ))
                8       (set @d (date (str->num (sub  0 4 s))
                                      (str->num (sub  4 2 s))
                                      (str->num (sub  6 2 s)) ))
                10      (set @d (date (str->num (sub  0 4 s))
                                      (str->num (sub  4 2 s))
                                      (str->num (sub  6 2 s))
                                      (str->num (sub  8 2 s)) ))
                12      (set @d (date (str->num (sub  0 4 s))
                                      (str->num (sub  4 2 s))
                                      (str->num (sub  6 2 s))
                                      (str->num (sub  8 2 s))
                                      (str->num (sub 10 2 s)) ))
                14      (set @d (date (str->num (sub  0 4 s))
                                      (str->num (sub  4 2 s))
                                      (str->num (sub  6 2 s))
                                      (str->num (sub  8 2 s))
                                      (str->num (sub 10 2 s))
                                      (str->num (sub 12 2 s)) )))
        (datep @d) )

(defnet str->date2 (s @d)
        (deflocal gg mm aa i)

        (ltrim s)
        (search " " s i)
        (set gg (str->num (sub 0 i s)))
        (integerp gg)
        (set s (sub (+ i 1) (maxint) s))
        (ltrim s)
        (alt    (lmatch setidx mm remove case s
                        "gennaio" "febbraio" "marzo" "aprile" "maggio" "giugno"
                        "luglio" "agosto" "settembre" "ottobre" "novembre" "dicembre" )
                (lmatch setidx mm remove case s
                        "gen" "feb" "mar" "apr" "mag" "giu"
                        "lug" "ago" "set" "ott" "nov" "dic" ))
        (inc mm)
        (ltrim s)
        (rtrim s)
        (set aa (str->num s))
        (integerp aa)
        (set @d (date aa mm gg))
        (datep @d) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun people-age-date (birthdate d)
        (approx1 (/ (- d birthdate) 31557600)) )

(defun people-age (birthdate)
        (people-age-date birthdate (now)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun csv-fields (s) net csv-fields)
(defnet csv-fields (s @q)
        (deflocal usetab i)

        (stringp s)
        (set @q (queue))
        (set usetab false)
        (opt*   (alt    (seq    (search "\t" s i)
                                (queue-put @q (sub 0 i s))
                                (set s (sub (+ i 1) (maxint) s))
                                (set usetab true) )
                        (seq    (not usetab)
                                (lmatch remove s "\"")
                                (search "\"" s i)
                                (queue-put @q (sub 0 i s))
                                (set s (sub (+ i 1) (maxint) s))
                                (alt    (= s "")
                                        (lmatch remove s ",") ))
                        (seq    (not usetab)
                                (search "," s i)
                                (queue-put @q (sub 0 i s))
                                (set s (sub (+ i 1) (maxint) s)) )
                        (seq    (queue-put @q s)
                                (fail) ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun isbn-is-valid (s) net isbn-is-valid)
(defnet isbn-is-valid (s @res)
        (set @res true)
        (alt    (isbn13-is-valid s)
                (isbn10-is-valid s)
                (set @res false) ))

(defnet isbn13-is-valid (s)
        (deflocal c p t)

        (= (length s) 13)
        (set p 1)
        (set t 0)
        (for c in s do
                (in c '0' .. '9')
                (inc t (* p (- (length c) (length '0'))))
                (set p (- 4 p)) )
        (= (% t 10) 0) )

(defnet isbn10-is-valid (s)
        (deflocal c p t)

        (= (length s) 10)
        (set p 10)
        (set t 0)
        (for c in (sub 0 9 s) do
                (in c '0' .. '9')
                (inc t (* p (- (length c) (length '0'))))
                (dec p) )
        (set c <s 9>)
        (alt    (seq    (in c '0' .. '9')
                        (inc t (- (length c) (length '0'))) )
                (seq    (= c 'X')
                        (inc t 10) ))
        (= (% t 11) 0) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun int2roman (n) net int2roman)
(defnet int2roman (n @s)
        (set @s (tile (div n 1000) 'M'))
        (set n (% n 1000))
        (if (= n 999)
        then    (inc @s "IM")
                (set n 0) )
        (if (= n 995)
        then    (inc @s "VM")
                (set n 0) )
        (if (>= n 990)
        then    (inc @s "XM")
                (dec n 990) )
        (if (in n 950 .. 959)
        then    (inc @s "LM")
                (dec n 950) )
        (if (>= n 900)
        then    (inc @s "CM")
                (dec n 900) )
        (if (>= n 500)
        then    (inc @s "D")
                (dec n 500) )
        (if (= n 499)
        then    (inc @s "ID")
                (set n 0) )
        (if (= n 495)
        then    (inc @s "VD")
                (set n 0) )
        (if (>= n 490)
        then    (inc @s "XD")
                (dec n 490) )
        (if (in n 450 .. 459)
        then    (inc @s "LD")
                (dec n 450) )
        (if (>= n 400)
        then    (inc @s "CD")
                (dec n 400) )
        (inc @s (tile (div n 100) 'C'))
        (set n (% n 100))
        (if (= n 99)
        then    (inc @s "IC")
                (set n 0) )
        (if (= n 95)
        then    (inc @s "VC")
                (set n 0) )
        (if (>= n 90)
        then    (inc @s "XC")
                (dec n 90) )
        (if (>= n 50)
        then    (inc @s "L")
                (dec n 50) )
        (if (= n 49)
        then    (inc @s "IL")
                (set n 0) )
        (if (= n 45)
        then    (inc @s "VL")
                (set n 0) )
        (if (>= n 40)
        then    (inc @s "XL")
                (dec n 40) )
        (inc @s (tile (div n 10) 'X'))
        (set n (% n 10))
        (if (= n 9)
        then    (inc @s "IX")
                (set n 0) )
        (if (= n 4)
        then    (inc @s "IV")
                (set n 0) )
        (if (>= n 5)
        then    (inc @s "V")
                (dec n 5) )
        (inc @s (tile n 'I')) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun odtpath->txt (path) net odtpath->txt)
(defnet odtpath->txt (path @s)
        (deflocal tmp s)

        (mktmpdir tmp)
        (alt    (odtpath->txt-low tmp path @s)
                (seq    (rmhier tmp)
                        (fail) ))
        (rmhier tmp) )

(defun odtraw->txt (odt) net odtraw->txt)
(defnet odtraw->txt (odt @s)
        (deflocal tmp path)

        (mktmpdir tmp)
        (alt    (seq    (set path (+ tmp "/0.odt"))
                        (raw-save path odt)
                        (odtpath->txt-low tmp path @s) )
                (seq    (rmhier tmp)
                        (fail) ))
        (rmhier tmp) )

(defnet odtpath->txt-low (tmp path @s)
        (deflocal s i)

        (set s (+ tmp "/0.txt"))
        (if (path-is-odt path)
        then    (system "trpodt2txt --encoding=UTF-8 --width=-1 --output="
                        (pathquote s) " " (pathquote path)
                        " >/dev/null 2>/dev/null" )
        else    (truep (path-is-epub path))
                (system "epub2txt -n " (pathquote path) " >" (pathquote s)
                        " 2>/dev/null" ))
        (set s (str-load s))
        (stringp s)
        (set @s "")
        (repeat (str-readline s tmp)
                until (= tmp undef)
                (rtrim tmp)
                ; questi brutti hack servono per ovviare alle lunghissime
                ; linee tratteggiate generate da odt2txt in
                ; corrispondenza dei paragrafi H1, H2...
                (if (rmatch tmp "=")
                then    (set i (rtrim tmp '='))
                        (if (> (- (length tmp) (length i)) 8)
                        then    (set tmp (+ i "========")) )
                else    (if (rmatch tmp "-")
                then    (set i (rtrim tmp '-'))
                        (if (> (- (length tmp) (length i)) 8)
                        then    (set tmp (+ i "--------")) )))
                (alt    (<= (length tmp) 60)
                        (seq    (search " " tmp i)
                                (<= i 60) )
                        (print "odt->txt warning: linea lunga senza spazi" nl
                               tmp nl ))
                (inc @s tmp "\n") )
        (rtrim @s '\n') )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet odtpath->pixlist (path dstpath @cnt)
        (deflocal tmp a)

        (mktmpdir tmp)
        (alt    (seq    (system "cd " tmp " && unzip " (pathquote path)
                                " >/dev/null 2>/dev/null" )
                        (set a (array 2))
                        (set <a 0> dstpath)
                        (set <a 1> @cnt)
                        (filesystem-visit tmp (netptr odtpath->pixlist-cback) a)
                        (set @cnt <a 1>)
                        (rmhier tmp) )
                (seq    (rmhier tmp)
                        (fail) )))

(defnet odtpath->pixlist-cback (path name a)
        (deflocal m ext)

        (set m (magic-file path))
        (opt    (not (rmatch path "/Thumbnails/thumbnail.png"))
                (alt    (seq    (search case "JPEG image data" m)
                                (set ext "jpg") )
                        (seq    (search case "PNG image data" m)
                                (set ext "png") ))
                (filecopy path (+ <a 0> "/" (int->str <a 1> 9 '0') "." ext))
                (inc <a 1>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet truep (cond) (= cond true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun random-range (a b)
        (+ a (random (- b a -1))) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun random-letter ()
        (random-letter-low (random 52)) )

(defun random-letter-low (n)
        (if (< n 26) (+ 'A' n) (+ (+ 'a' -26) n)) )

(defun random-digit ()
        (+ '0' (random 10)) )

(defun random-string-low (n p)
        (if (= n 0) "" (+ (random-string-low (- n 1) p)
                          (if (< (random (den p)) (num p))
                                (random-digit)
                                (random-letter) ))))

(defun random-string (n)
        (random-string-low n 0) )

(defun random-alphanumeric-string (n)
        (random-string-low n 0.25) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun less0 (x y) (< <x 0> <y 0>))
(defun less1 (x y) (< <x 1> <y 1>))
(defun less2 (x y) (< <x 2> <y 2>))
(defun less3 (x y) (< <x 3> <y 3>))
(defun less4 (x y) (< <x 4> <y 4>))
(defun less5 (x y) (< <x 5> <y 5>))
(defun less6 (x y) (< <x 6> <y 6>))
(defun less7 (x y) (< <x 7> <y 7>))
(defun less8 (x y) (< <x 8> <y 8>))
(defun less9 (x y) (< <x 9> <y 9>))
(defun lesscar (x y) (< (car x) (car y)))
(defun lesscdr (x y) (< (cdr x) (cdr y)))
(defun greater-1 (x y) (> x y))
(defun greater0 (x y) (> <x 0> <y 0>))
(defun greater1 (x y) (> <x 1> <y 1>))
(defun greater2 (x y) (> <x 2> <y 2>))
(defun greater3 (x y) (> <x 3> <y 3>))
(defun greater4 (x y) (> <x 4> <y 4>))
(defun greater5 (x y) (> <x 5> <y 5>))
(defun greater6 (x y) (> <x 6> <y 6>))
(defun greater7 (x y) (> <x 7> <y 7>))
(defun greater8 (x y) (> <x 8> <y 8>))
(defun greater9 (x y) (> <x 9> <y 9>))
(defun greatercar (x y) (> (car x) (car y)))
(defun greatercdr (x y) (> (cdr x) (cdr y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun approxx (x n) (if (rationalp x) (approxr x n) (+ (approxr (re x) n) (* (approxr (im x) n) (sqrt -1)))))
(defun approxr (x n) (/ (rint (* x n)) n))
(defun approx0 (x)  (approxx x 1))
(defun approx1 (x)  (approxx x 10))
(defun approx2 (x)  (approxx x 100))
(defun approx3 (x)  (approxx x 1000))
(defun approx4 (x)  (approxx x 10000))
(defun approx5 (x)  (approxx x 100000))
(defun approx6 (x)  (approxx x 1000000))
(defun approx7 (x)  (approxx x 10000000))
(defun approx8 (x)  (approxx x 100000000))
(defun approx9 (x)  (approxx x 1000000000))
(defun approx10 (x) (approxx x 10000000000))
(defun approx (x cifre) (approxx x (pow 10 cifre)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun conjugate (c) (+ (re c) (* -(im c) (sqrt -1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun rational-default (x defval)
        (if (rationalp x) x defval) )

(defun rational-default-zero (x)
        (rational-default x 0) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet box-size-fixed (w-old h-old w-fixed h-fixed @w-new @h-new)
        (deflocal r)

        (set r (min (/ w-fixed w-old) (/ h-fixed h-old)))
        (set @w-new (rint (* r w-old)))
        (set @h-new (rint (* r h-old))) )

(defnet box-size-max (w-old h-old w-max h-max @w-new @h-new)
        (deflocal r)

        (set r (min 1 (/ w-max w-old) (/ h-max h-old)))
        (set @w-new (rint (* r w-old)))
        (set @h-new (rint (* r h-old))) )

(defnet box-size-min (w-old h-old w-min h-min @w-new @h-new)
        (deflocal r)

        (set r (max 1 (min (/ w-min w-old) (/ h-min h-old))))
        (set @w-new (rint (* r w-old)))
        (set @h-new (rint (* r h-old))) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun queue->list (q) net queue->list)
(defnet queue->list (q @l)
        (deflocal i)

        (queuep q)
        (set @l nil)
        (for i in 0 .. (- (length q) 1) rev do
                (list-push @l <q i>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun assoc->array (asc) net assoc->array)
(defnet assoc->array (asc @arr)
        (deflocal i)

        (assocp asc)
        (set @arr (array (length asc)))
        (for i in asc do
                (set <@arr (for-pos)> i) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun assoc-default (default-list) net assoc-default)
(defnet assoc-default (default-list @a)
        (deflocal i)

        (set @a (assoc))
        (for i in default-list do
                (set <@a (car i)> (cdr i)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun assoc-choice (asc) net assoc-choice)
(defnet assoc-choice (asc @elem)
        (for @elem in asc do until true) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun words (s) net words)
(defun words-exclude (s l) net words-exclude)

(defnet words (s @a)
        (words-exclude s nil @a) )

(defnet words-exclude (s l @a)
        (deflocal w)

        (set @a (assoc))
        (for w in l do
                (set <@a w> 1) )
        (words-add @a s)
        (for w in l do
                (assoc-clr @a w) ))

(defnet words-add (a s)
        (deflocal c i)

        (set s (utf8-tolower s))
        (for c in s do
                (if (in c " \n\r\f\t.,;:?!/\\\"'<=>&()[]{}|")
                then    (if (<> i undef)
                        then    (words-put a (sub i (- (for-pos) i) s))
                                (clr i) )
                else    (if (= i undef)
                        then    (set i (for-pos)) )))
        (if (<> i undef)
        then    (words-put a (sub i (maxint) s)) ))

(defnet words-put (a s)
        (if (and (>= (length s) 3)
                 (= (str->num s) undef) )
        then    (inc <a s>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet list-push (@lst obj)
        (set @lst (cons obj @lst)) )

(defnet list-pop (@lst @obj)
        (set @obj (car @lst))
        (set @lst (cdr @lst)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mkdirhier (path)
        (deflocal i)

        (if (not (pathexists path))
        then    (rtrim path '/')
                (search "/" path i (maxint))
                (mkdirhier (sub 0 (+ i 1) path))
                (mkdir path) ))

(defnet rmhier (path)
        (deflocal p)

        (rtrim path '/')
        (<> path "")
        (if (pathexists path)
        then    (if (isdir path)
                then    (for p in (directory path) do
                                (if (and (<> p ".") (<> p ".."))
                                then    (rmhier (+ path "/" p)) )))
                (remove path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun int->str (n len filler) (int->str0 (sprint n) len filler))
(defun int->str0 (s len filler)
        (if (>= (length s) len)
                s
                (+ (tile (- len (length s)) filler) s) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet print-tab (nskip nlen s)
        (deflocal t u i)

        (repeat (set t (sub 0 nlen s))
                (set u (sub (length t) (maxint) s))
                (opt    (<> u "")
                        (<> <u 0> ' ')
                        (search " " t i (maxint))
                        (set t (sub 0 i s))
                        (set u (sub (+ i 1) (maxint) s)) )
                (print t nl)
                until (= u "")
                (set s (ltrim u))
                (print (tile nskip)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet filecopy (ipath opath)
        (deflocal raw)

        (set raw (raw 65536))
        (alt    (filecopy-raw ipath opath raw)
                (seq    (close raw)
                        (fail) ))
        (close raw)
        (opt (utime opath (ftime ipath))) )

(defnet filecopy-raw (ipath opath raw)
        (deflocal fi fo)

        (set fi (fopenro ipath))
        (<> fi undef)
        (set fo (fcreate opath))
        (if (= fo undef)
        then    (close fi)
                (fail) )
        (alt    (filecopy-basic fi fo (length fi) raw)
                (seq    (close fi fo)
                        (remove opath)
                        (fail) ))
        (close fi fo) )

(defnet filecopy-basic (fi fo rem raw)
        (deflocal i)

        (while (> rem 0) do
                (set i (raw-read raw fi rem))
                (> i 0)
                (= i (raw-write raw fo i))
                (set rem (- rem i)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; cerca la prima istanza della stringa s (non vuota) nel file f

(defnet filesearch (f s)
        (deflocal actpos q t u c)

        (stringp s)
        (> (length s) 0)
        (set s (explode s))
        (set actpos (fpos f))
        (set q (queue))
        (set t s)
        (repeat (if (= (length q) 0)
                then    (set c (freadchar f))
                        (if (not (charp c))
                        then    (fsetpos actpos f)
                                (fail) )
                else    (set c (queue-get q)) )
                (if (= c (car t))
                then    (set t (cdr t))
                else    (if (<> t s)
                        then    (set u s)
                                (repeat (queue-put q (car u))
                                        (set u (cdr u))
                                        until (= u t) )
                                (queue-put q c)
                                (skip (queue-get q))
                                (set t s) ))
                until (= t nil) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mktmpdir (@path)
        (deflocal prefix i)

        (set prefix (+ "/tmp/" (random-alphanumeric-string 4)))
        (set i 0)
        (repeat (set @path (+ prefix (int->str i 4 '0')))
                (alt    (seq    (not (pathexists @path))
                                (mkdir @path)
                                (set i 0) )
                        (inc i) )
                until (= i 0) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mkmirror (srcdir dstdir date)
        (deflocal raw)

        (not (pathexists dstdir))
        (set raw (raw 65536))
        (alt    (mkmirror-rec srcdir dstdir date raw)
                (seq    (close raw)
                        (rmhier dstdir)
                        (fail) ))
        (close raw) )

(defnet mkmirror-rec (srcdir dstdir date raw)
        (deflocal p path newdst)

        (mkdir dstdir)
        (for p in (directory srcdir) do
                (if (and (<> p ".") (<> p ".."))
                then    (set path (+ srcdir "/" p))
                        (set newdst (+ dstdir "/" p))
                        (if (isdir path)
                        then    (mkmirror-rec path newdst date raw)
                        else    (if (isreg path)
                                then    (filecopy-raw path newdst raw)
                                        (utime newdst date) ))))
        (utime dstdir date) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun system-stdout->str (cmdline) net system-stdout->str)
(defnet system-stdout->str (cmdline @str)
        (deflocal tmpdir tmp)

        (clr @str)
        (mktmpdir tmpdir)
        (opt    (set tmp (+ tmpdir "/fifo"))
                (mkfifo tmp)
                (system cmdline " > " tmp " 2>/dev/null &")
                (set @str (str-load tmp)) )
        (rmhier tmpdir) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun ipv4-external-address () net ipv4-external-address)
(defnet ipv4-external-address (@addr)
        (deflocal tmpdir tmppath cmd cnt s l i)

        (clr @addr)
        (mktmpdir tmpdir)
        (opt    (set tmppath (+ tmpdir "/a"))
                (set cmd (+ "wget ipinfo.io/ip -O " tmppath))
                (system cmd " >/dev/null 2>/dev/null &")
                (set cnt 0)
                (repeat (sleep 0.05)
                        (set s (system-stdout->str "ps xa"))
                        (clr i)
                        (repeat (str-readline s l)
                                until (= l undef)
                                (if (search cmd l)
                                then    (ltrim l)
                                        (search " " l i)
                                        (set i (str->num (sub 0 i l))) ))
                        until (not (integerp i))
                        (inc cnt)
                        (if (= cnt 32) ; max 1.6 secondi
                        then    (system "sudo kill -SIGKILL " i " >/dev/null 2>/dev/null")
                                (fail) ))
                (set @addr (str-load tmppath)) )
        (rmhier tmpdir)
        (stringp @addr)
        (trim-trn @addr)
        (set s @addr)
        (search "." s i)
        (integerp (str->num (sub 0 i s)))
        (set s (sub (+ i 1) (maxint) s))
        (search "." s i)
        (integerp (str->num (sub 0 i s)))
        (set s (sub (+ i 1) (maxint) s))
        (search "." s i)
        (integerp (str->num (sub 0 i s)))
        (integerp (str->num (sub (+ i 1) (maxint) s))) )

(defnet ipv4-connected-low (@res @addr)
        (deflocal i)

        (set @res false)
        (opt    (set @addr (ipv4-external-address))
                (stringp @addr)
                (not (lmatch @addr "192.168.1."))
                (not (rmatch @addr ".0.0"))
                (set @res true) ))

(defun ipv4-connected () net ipv4-connected-func)
(defnet ipv4-connected-func (@res)
        (deflocal addr)
        (ipv4-connected-low @res addr) )

(defnet ipv4-connected () (truep (ipv4-connected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun curl-default-useragent ()
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.89 Safari/537.36" )
        ;"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12" )

(defun curl-create-default (useragent) net curl-create-default)
(defnet curl-create-default (useragent @c)
        (set @c (curl-easy-init))
        (<> @c undef)
        (curl-easy-setopt-ssl-verifypeer @c false)
        ;(curl-easy-setopt-capath @c "cacert.pem")
        (curl-easy-setopt-followlocation @c true)
        (curl-easy-setopt-maxredirs @c 10)
        (curl-easy-setopt-useragent @c (if (stringp useragent) useragent (curl-default-useragent))) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun download-as-string (url)
        (download-as-string-low undef url) )

(defun download-as-string-low (useragent url) net download-as-string-low)
(defnet download-as-string-low (useragent url @str)
        (deflocal c)

        (curl-create-default useragent c)
        (alt    (download-as-string-curl c url @str)
                (seq    (close c)
                        (fail) ))
        (close c) )

(defun download-as-raw (url)
        (download-as-raw-low undef url) )

(defun download-as-raw-low (useragent url) net download-as-raw-low)
(defnet download-as-raw-low (useragent url @raw)
        (deflocal c)

        (curl-create-default useragent  c)
        (alt    (download-as-raw-curl c url @raw)
                (seq    (close c)
                        (fail) ))
        (close c) )

(defnet download-as-string-curl (c url @str)
        (download-as-stringraw-curl-basic c url @str true) )

(defnet download-as-raw-curl (c url @raw)
        (download-as-stringraw-curl-basic c url @raw false) )

(defnet download-as-stringraw-curl-basic (c url @res string)
        (deflocal a)

        (set a (array default (if string "" (raw 0)) 1))
        (curl-easy-setopt-errorbuffer c true)
        (curl-easy-setopt-filetime c false)
        (curl-easy-setopt-progressfunction c undef)
        (curl-easy-setopt-url c url)
        (curl-easy-setopt-writefunction c
                (if string (netptr download-as-string-cback)
                           (netptr download-as-raw-cback) )
                a )
        (alt    (curl-easy-perform c)
                (seq    (fprint (stderr) "curl error: " (curl-easy-getinfo-errorbuffer c) nl)
                        (fflush (stderr))
                        (fail) ))
        (set @res <a 0>) )

(defnet download-as-string-cback (raw a)
        (inc <a 0> (raw->str raw)) )

(defnet download-as-raw-cback (raw a)
        (deflocal oldraw)

        (set oldraw <a 0>)
        (inc <a 0> raw)
        (close oldraw) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet download-as-file (url path)
        (download-as-file-low undef url path) )

(defnet download-as-file-low (useragent url path)
        (deflocal c)

        (curl-create-default useragent c)
        (alt    (download-as-file-curl c url path)
                (seq    (close c)
                        (fail) ))
        (close c) )

(defnet download-as-file-curl (c url path)
        (deflocal tmp-path f)

        (set tmp-path (+ path ".part"))
        (opt (remove tmp-path))
        (set f (fcreate tmp-path))
        (<> f undef)
        (curl-easy-setopt-errorbuffer c true)
        (curl-easy-setopt-filetime c true)
        (curl-easy-setopt-progressfunction c
                (netptr curl-progress)
                (cons (+ " dloading " (str-ellipsize-start (fullpath->name path) 22) ": ") (now)) )
        (curl-easy-setopt-url c url)
        (curl-easy-setopt-writefunction c
                (netptr download-as-file-cback) f )
        (alt    (curl-easy-perform c)
                (seq    (close f)
                        (fprint (stderr) nl "curl error: "
                                (curl-easy-getinfo-errorbuffer c) nl )
                        (fflush (stderr))
                        (fail) ))
        (close f)
        (opt (remove path))
        (rename tmp-path path)
        (opt (utime path (curl-easy-getinfo-filetime c)))
        (fprint (stderr) nl) )

(defnet download-as-file-cback (raw f)
        (= (length raw) (raw-write raw f (length raw))) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet upload-curl (c url path)
        (deflocal f i)

        (set f (fopenro path))
        (<> f undef)
        (curl-easy-setopt-errorbuffer c true)
        (curl-easy-setopt-progressfunction c
                (netptr curl-progress)
                (cons (+ " uloading " (str-ellipsize-start (fullpath->name path) 22) ": ") (now)) )
        (curl-easy-setopt-url c url)
        (curl-easy-setopt-readfunction c (length f) (netptr upload-cback) f)
        (alt    (curl-easy-perform c)
                (seq    (close f)
                        (fprint (stderr) nl "curl error: "
                                (curl-easy-getinfo-errorbuffer c) nl )
                        (fail) ))
        (close f)
        (fprint (stderr) nl) )

(defnet upload-cback (raw f)
        (= (length raw) (raw-read raw f (length raw))) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet curl-progress (tot act data)
        (fprint (stderr) (car data) act '/' tot " (" (rint (/ act tot 0.01)) "%) "
                         (bitrate act (- (now) (cdr data))) " kb/s       \r" )
        (fflush (stderr)) )

(defun bitrate (bytes s)
        (/ (rint (/ bytes s 100)) 10) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun pix-add-margins (pix n color) net pix-add-margins)
(defnet pix-add-margins (pix n color @pix)
        (deflocal w h)

        (set w (+ (width pix) n n))
        (set h (+ (height pix) n n))
        (set @pix (pix-create w h))
        (if (<> color undef)
        then    (pix-draw-box @pix 0 0 w h color) )
        (pix-draw-pix @pix n n pix) )

(defun pix-clone (pix) (pix-add-margins pix 0 undef))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun pix-scale-treep (pix w h) (pix-scale pix w h))

(defun pix-sws-scale (pix w h alg) net pix-sws-scale)
(defnet pix-sws-scale (pix w h alg @res)
        (deflocal ctx)
        (set w (rint w))
        (set h (rint h))
        (set ctx (av-sws-context (width pix) (height pix) w h alg))
        (<> ctx undef)
        (set @res (pix-create w h))
        (alt    (av-sws-scale ctx pix @res)
                (seq    (close ctx @res)
                        (fail) ))
        (close ctx) )

(defun pix-sws-scale-fast-bilinear (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_FAST_BILINEAR)) )

(defun pix-sws-scale-bilinear (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_BILINEAR)) )

(defun pix-sws-scale-bicubic (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_BICUBIC)) )

(defun pix-sws-scale-x (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_X)) )

(defun pix-sws-scale-point (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_POINT)) )

(defun pix-sws-scale-area (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_AREA)) )

(defun pix-sws-scale-bicublin (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_BICUBLIN)) )

(defun pix-sws-scale-gauss (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_GAUSS)) )

(defun pix-sws-scale-sinc (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_SINC)) )

(defun pix-sws-scale-lanczos (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_LANCZOS)) )

(defun pix-sws-scale-spline (pix w h)
        (pix-sws-scale pix w h (cmacro SWS_SPLINE)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun pix-cv-scale (pix w h flags) net pix-cv-scale)
(defnet pix-cv-scale (pix w h flags @res)
        (set w (rint w))
        (set h (rint h))
        (set @res (pix-create w h))
        (alt    (cv-pix-warp-affine pix @res
                        (cv-get-affine-transform 0 0 0 0
                                (- (width pix) 1) 0 (- w 1) 0
                                0 (- (height pix) 1) 0 (- h 1) ) flags )
                (seq    (close @res)
                        (fail) )))

(defun pix-cv-scale-nearest-neighbour (pix w h)
        (pix-cv-scale pix w h (cmacro CV_INTER_NN)) )

(defun pix-cv-scale-bilinear (pix w h)
        (pix-cv-scale pix w h (cmacro CV_INTER_LINEAR)) )

(defun pix-cv-scale-bicubic (pix w h)
        (pix-cv-scale pix w h (cmacro CV_INTER_CUBIC)) )

(defun pix-cv-scale-area (pix w h)
        (pix-cv-scale pix w h (cmacro CV_INTER_AREA)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet pix-binarize-wolf (@pix)
        (pix-binarize-wolf-low @pix 0.6) )

(defnet pix-binarize-wolf-low (@pix k)
        (deflocal tmpdir tmp1 tmp2 pix)

        (pixp @pix)
        (mktmpdir tmpdir)
        (set tmp1 (+ tmpdir "/1.ppm"))
        (set tmp2 (+ tmpdir "/2.pgm"))
        (alt    (seq    (pix-save-pnm-noalpha @pix tmp1)
                        (system "binarizewolfjolion -k " k " " tmp1 " " tmp2 " >/dev/null 2>/dev/null")
                        (set pix (pix-load tmp2))
                        (pixp pix)
                        (close @pix)
                        (set @pix pix)
                        (rmhier tmpdir) )
                (seq    (rmhier tmpdir)
                        (fail) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun djvu-jpeg-list (djvupath) net  djvu-jpeg-list)
(defnet djvu-jpeg-list (djvupath @l)
        (deflocal tmpdir tmp f l i)

        (mktmpdir tmpdir)
        (set tmp (+ tmpdir "/fifo"))
        (mkfifo tmp)
        (alt    (seq    (system "djvudump " (pathquote djvupath) " > " tmp " 2>/dev/null &")
                        (set f (fopenro tmp))
                        (<> f undef)
                        (set @l (queue))
                        (repeat (set l (freadline f))
                                until (= l undef)
                                (ltrim l ' ' '\t')
                                (rtrim l ' ' '\t')
                                (opt    (lmatch remove l "FORM:DJVU")
                                        (search ".djvu}" l i (maxint))
                                        (set l (sub 0 i l))
                                        (rmatch case l ".jpg" ".jpeg")
                                        (search "{" l i)
                                        (queue-put @l (sub (+ i 1) (maxint) l)) ))
                        (close f)
                        (> (length @l) 0)
                        (rmhier tmpdir) )
                (seq    (rmhier tmpdir)
                        (fail) )))

(defnet djvu-jpeg-extract (djvupath @dest @tmpdir)
        (deflocal l i pg)

        (djvu-jpeg-list djvupath l)
        (mktmpdir @tmpdir)
        (alt    (seq    (set @dest (+ @tmpdir "/" (fullpath->name djvupath)))
                        (opt (rmatch case remove @dest ".djvu"))
                        (mkdir @dest)
                        (set djvupath (pathquote djvupath))
                        (set pg 1)
                        (for i in l do
                                (system "djvuextract -page=" pg " " djvupath " BGjp=" (pathquote (+ @dest "/" i))
                                        " >/dev/null 2>/dev/null" )
                                (inc pg) ))
                (seq    (rmhier @tmpdir)
                        (fail) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet av-seek (av framecnt)
        (deflocal n done pos i)

        (set n (av-index-entries av))
        (integerp n)
        (< framecnt n)
        (for i in 1 .. n do
                (if (av-index-keyframe av (for-pos))
                then    (if (<= (for-pos) framecnt)
                        then    (set pos (for-pos)) )
                        (set done (>= (for-pos) framecnt)) )
                until done )
        (integerp pos)
        (av-seek-frame av pos)
        (av-skip-frame av (- framecnt pos)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet iup-ok-cb (self)
        (iup-set-int (iup-get-dialog self) "STATUS" 1)
        (fail) )

(defnet iup-cancel-cb (self)
        (fail) )

(defnet iup-success-cb (self)
        (success) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet iup-info (parent text) (iup-info-warning-error 0 parent text))
(defnet iup-warning (parent text) (iup-info-warning-error 1 parent text))
(defnet iup-error (parent text) (iup-info-warning-error 2 parent text))

(defnet iup-info-warning-error (tipo parent text)
        (deflocal img hbox bt-ok bt-ok-img dlg i)

        (set i (iup-label))
        (case tipo of
                0       (set img (iup-image-rgba (pix-load-static "48x48/dialog-information-2.png")))
                1       (set img (iup-image-rgba (pix-load-static "48x48/dialog-important-2.png")))
                2       (set img (iup-image-rgba (pix-load-static "48x48/dialog-error-4.png"))) )
        (iup-set-attribute-handle i "IMAGE" img)

        (set text (iup-label (utf8-validate0 text)))

        (set hbox (iup-hbox i text))
        (iup-set-str-attribute hbox "ALIGNMENT" "ACENTER")
        (iup-set-int hbox "GAP" 14)

        (set bt-ok (iup-button "Ok"))
        (iup-set-callback bt-ok "ACTION" (netptr iup-cancel-cb))
        (set bt-ok-img (iup-image-rgba (pix-load-static "16x16/dialog-apply.png")))
        (iup-set-attribute-handle bt-ok "IMAGE" bt-ok-img)
        (iup-set-str-attribute bt-ok "PADDING" "2x2")
        (iup-set-int bt-ok "SPACING" 6)

        (set i (iup-hbox (iup-fill) bt-ok (iup-fill)))

        (set i (iup-vbox
                        hbox
                        i ))
        (iup-set-str-attribute i "MARGIN" "4x4")
        (iup-set-int i "GAP" 0)

        (set dlg (iup-dialog i))
        (if (<> parent undef)
        then    (iup-set-attribute-handle dlg "PARENTDIALOG" (iup-get-dialog parent)) )
        (iup-set-str-attribute dlg "TITLE" <[ "Info" "Avviso" "Errore" ] tipo>)
        (iup-set-str-attribute dlg "DIALOGFRAME" "YES")
        (iup-set-attribute-handle dlg "DEFAULTENTER" bt-ok)
        (iup-set-attribute-handle dlg "DEFAULTESC" bt-ok)

        (iup-popup dlg (cmacro IUP_CENTERPARENT) (cmacro IUP_CENTERPARENT))
        (close dlg)
        (close img bt-ok-img) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet iup-confirm (parent text)
        (deflocal img hbox bt-ok bt-ok-img bt-cancel bt-cancel-img dlg i)

        (set i (iup-label))
        (set img (iup-image-rgba (pix-load-static "48x48/dialog-question-2.png")))
        (iup-set-attribute-handle i "IMAGE" img)

        (set text (iup-label (utf8-validate0 text)))

        (set hbox (iup-hbox i text))
        (iup-set-str-attribute hbox "ALIGNMENT" "ACENTER")
        (iup-set-int hbox "GAP" 14)

        (set bt-ok (iup-button "Conferma"))
        (iup-set-callback bt-ok "ACTION" (netptr iup-ok-cb))
        (set bt-ok-img (iup-image-rgba (pix-load-static "16x16/dialog-apply.png")))
        (iup-set-attribute-handle bt-ok "IMAGE" bt-ok-img)
        (iup-set-str-attribute bt-ok "PADDING" "2x2")
        (iup-set-int bt-ok "SPACING" 6)

        (set bt-cancel (iup-button "Annulla"))
        (iup-set-callback bt-cancel "ACTION" (netptr iup-cancel-cb))
        (set bt-cancel-img (iup-image-rgba (pix-load-static "16x16/dialog-cancel-3.png")))
        (iup-set-attribute-handle bt-cancel "IMAGE" bt-cancel-img)
        (iup-set-str-attribute bt-cancel "PADDING" "2x2")
        (iup-set-int bt-cancel "SPACING" 6)

        (set i (iup-hbox (iup-fill) bt-ok bt-cancel))

        (set i (iup-vbox
                        hbox
                        i ))
        (iup-set-str-attribute i "MARGIN" "4x4")
        (iup-set-int i "GAP" 0)

        (set dlg (iup-dialog i))
        (if (<> parent undef)
        then    (iup-set-attribute-handle dlg "PARENTDIALOG" (iup-get-dialog parent)) )
        (iup-set-str-attribute dlg "TITLE" "Richiesta di conferma")
        (iup-set-str-attribute dlg "DIALOGFRAME" "YES")
        (iup-set-attribute-handle dlg "DEFAULTENTER" bt-cancel)
        (iup-set-attribute-handle dlg "DEFAULTESC" bt-cancel)

        (iup-set-int dlg "STATUS" 0)
        (iup-popup dlg (cmacro IUP_CENTERPARENT) (cmacro IUP_CENTERPARENT))
        (set i (iup-get-int dlg "STATUS"))
        (close dlg)
        (close img bt-ok-img bt-cancel-img)
        (= i 1) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet iup-edit (parent a)
        (iup-edit-low parent a) )

(defnet iup-edit-low (parent a)
        (deflocal n i f)

        (arrayp a)
        (set n (length a))
        (>= n 1)
        (= n 1)
        (set f <a 0>)
        (= <f 1> "stringa")



        (iup-info parent "da finire")
        (fail) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet iup-edit-string (parent title label @s)
        (iup-edit-string-low parent title label false undef @s) )

(defnet iup-edit-password (parent title label @s)
        (iup-edit-string-low parent title label true undef @s) )

(defnet iup-edit-string-hints (parent title label hints @s)
        (iup-edit-string-low parent title label false hints @s) )

(defnet iup-edit-string-low (parent title label password hints @s)
        (deflocal text hbox bt-ok bt-ok-img bt-cancel bt-cancel-img dlg i)

        (set i (length hints))
        (if (and (integerp i) (> i 0))
        then    (set text (iup-list))
                (iup-set-str-attribute text "DROPDOWN" "YES")
                (iup-set-str-attribute text "EDITBOX" "YES")
                (for i in hints do
                        (iup-set-str-attribute text (+ (for-pos) 1) (utf8-validate0 i)) )
        else    (set text (iup-text))
                (iup-set-str-attribute text "PASSWORD" (if password "YES" "NO")) )
        (iup-set-int text "VISIBLECOLUMNS" 40)
        (iup-set-str-attribute text "VALUE" (if (stringp @s) (utf8-validate0 @s) ""))

        (set hbox (iup-hbox (iup-label (+ label ":")) text))
        (iup-set-str-attribute hbox "ALIGNMENT" "ACENTER")
        (iup-set-int hbox "GAP" 6)

        (set bt-ok (iup-button "Conferma"))
        (iup-set-callback bt-ok "ACTION" (netptr iup-ok-cb))
        (set bt-ok-img (iup-image-rgba (pix-load-static "16x16/dialog-apply.png")))
        (iup-set-attribute-handle bt-ok "IMAGE" bt-ok-img)
        (iup-set-str-attribute bt-ok "PADDING" "2x2")
        (iup-set-int bt-ok "SPACING" 6)

        (set bt-cancel (iup-button "Annulla"))
        (iup-set-callback bt-cancel "ACTION" (netptr iup-cancel-cb))
        (set bt-cancel-img (iup-image-rgba (pix-load-static "16x16/dialog-cancel-3.png")))
        (iup-set-attribute-handle bt-cancel "IMAGE" bt-cancel-img)
        (iup-set-str-attribute bt-cancel "PADDING" "2x2")
        (iup-set-int bt-cancel "SPACING" 6)

        (set i (iup-hbox (iup-fill) bt-ok bt-cancel))

        (set i (iup-vbox
                        hbox
                        i ))
        (iup-set-str-attribute i "MARGIN" "4x4")
        (iup-set-int i "GAP" 0)

        (set dlg (iup-dialog i))
        (if (<> parent undef)
        then    (iup-set-attribute-handle dlg "PARENTDIALOG" (iup-get-dialog parent)) )
        (iup-set-str-attribute dlg "TITLE" title)
        (iup-set-str-attribute dlg "DIALOGFRAME" "YES")
        (iup-set-attribute-handle dlg "DEFAULTENTER" bt-ok)
        (iup-set-attribute-handle dlg "DEFAULTESC" bt-cancel)

        (iup-set-int dlg "STATUS" 0)
        (iup-popup dlg (cmacro IUP_CENTERPARENT) (cmacro IUP_CENTERPARENT))
        (set i (iup-get-int dlg "STATUS"))
        (set @s (iup-get-str-attribute text "VALUE"))
        (close dlg)
        (close bt-ok-img bt-cancel-img)
        (= i 1) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun iup-choose-date (self date) net iup-choose-date)
(defnet iup-choose-date (self date @date)
        (deflocal dlg dat vbox hbox bt-ok bt-cancel bt-ok-img bt-cancel-img)

        (if (= date undef) then (set date (now)))
        (datep date)

        (set dat (iup-calendar))
        (iup-set-str-attribute dat "VALUE" (iup-choose-date-esrap date))

        (set bt-ok (iup-button "Ok"))
        (iup-set-callback bt-ok "ACTION" (netptr iup-ok-cb))
        (set bt-ok-img (iup-image-rgba (pix-load-static "16x16/dialog-apply.png")))
        (iup-set-attribute-handle bt-ok "IMAGE" bt-ok-img)
        (iup-set-str-attribute bt-ok "PADDING" "2x2")
        (iup-set-int bt-ok "SPACING" 6)

        (set bt-cancel (iup-button "Annulla"))
        (iup-set-callback bt-cancel "ACTION" (netptr iup-cancel-cb))
        (set bt-cancel-img (iup-image-rgba (pix-load-static "16x16/dialog-cancel-3.png")))
        (iup-set-attribute-handle bt-cancel "IMAGE" bt-cancel-img)
        (iup-set-str-attribute bt-cancel "PADDING" "2x2")
        (iup-set-int bt-cancel "SPACING" 6)

        (set hbox (iup-hbox
                (iup-fill)
                bt-ok
                bt-cancel ))

        (set vbox (iup-vbox dat hbox))
        (iup-set-str-attribute vbox "MARGIN" "6x6")
        (iup-set-int vbox "GAP" 2)

        (set dlg (iup-dialog vbox))
        (iup-set-int dlg "STATUS" 0)
        (iup-set-str-attribute dlg "TITLE" "Scegli la data")
        (iup-set-str-attribute dlg "DIALOGFRAME" "YES")
        (iup-set-attribute-handle dlg "DEFAULTENTER" bt-ok)
        (iup-set-attribute-handle dlg "DEFAULTESC" bt-cancel)
        (if (<> self undef)
        then    (iup-set-attribute-handle dlg "PARENTDIALOG" (iup-get-dialog self)) )
        (iup-popup dlg (cmacro IUP_CENTERPARENT) (cmacro IUP_CENTERPARENT))
        (if (= (iup-get-int dlg "STATUS") 1)
        then    (set @date (iup-choose-date-parse (iup-get-str-attribute dat "VALUE"))) )
        (close dlg)
        (close bt-ok-img bt-cancel-img) )

(defun iup-choose-date-esrap (date) net iup-choose-date-esrap)
(defnet iup-choose-date-esrap (date @s)
        (deflocal mm gg)

        (set mm (date-month date))
        (set gg (date-day date))
        (set @s (sprint (date-year date) "/"
                        (if (integerp mm) mm 1) "/"
                        (if (integerp gg) gg 1) )))

(defun iup-choose-date-parse (s) net iup-choose-date-parse)
(defnet iup-choose-date-parse (s @date)
        (deflocal i aa)

        (search "/" s i)
        (set aa (str->num (sub 0 i s)))
        (set s (sub (+ i 1) (maxint) s))
        (search "/" s i)
        (set @date (date aa (str->num (sub 0 i s)) (str->num (sub (+ i 1) (maxint) s))))
        (datep @date) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet gtk-flush ()
        (while (gtk-events-pending) do
                (gtk-main-iteration) ))

(defnet gtk-destroy ()
        (gtk-main-quit) )

(defnet gtk-close-win (win)
        (close win) )

(defnet gtk-dont-delete (e)
        (success) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet gtk-message-info--old (parent msg)
        (gtk-message0 (cmacro GTK_MESSAGE_INFO) parent msg) )

(defnet gtk-message-warning--old (parent msg)
        (gtk-message0 (cmacro GTK_MESSAGE_WARNING) parent msg) )

(defnet gtk-message-error--old (parent msg)
        (gtk-message0 (cmacro GTK_MESSAGE_ERROR) parent msg) )

(defnet gtk-message0 (type parent msg)
        (deflocal w)

        (set w (gtk-message-dialog-new parent 0 type
                        (cmacro GTK_BUTTONS_CLOSE) msg ))
        (skip (gtk-dialog-run w))
        (close w) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet gtk-question--old (parent msg)
        (deflocal w res)

        (set w (gtk-message-dialog-new parent 0
                (cmacro GTK_MESSAGE_QUESTION)
                (cmacro GTK_BUTTONS_OK_CANCEL)
                msg ))
        (set res (gtk-dialog-run w))
        (close w)
        (= res (cmacro GTK_RESPONSE_OK)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun gtk-iconed-button (pix msg net udata) net gtk-iconed-button)
(defnet gtk-iconed-button (pix msg net udata @btn)
        (deflocal hb)

        (set @btn (gtk-button-new))
        (set hb (gtk-hbox-new false 5))
        (gtk-container-add @btn hb)
        (gtk-box-pack-start hb (gtk-image-new-from-pixbuf pix) false false 0)
        (gtk-box-pack-start hb (gtk-label-new msg) false false 0)
        (gtk-signal-connect @btn "clicked" net udata) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun dgraph-create () (assoc))

(defnet dgraph-mknode (g name val)
        (deflocal a)

        (assocp g)
        (= <g name> undef)
        (set a (array 4))
        (set <a 0> (assoc)) ; archi in uscita
        (set <a 1> (assoc)) ; archi in ingresso
        (set <a 2> val)
        (set <a 3> (assoc)) ; attributi del nodo
        (set <g name> a) )

(defnet dgraph-rmnode (g name)
        (deflocal a aa)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set aa <a 0>)
        (while (> (length aa) 0) do
                (dgraph-rmedge g name (assoc-root aa)) )
        (set aa <a 1>)
        (while (> (length aa) 0) do
                (dgraph-rmedge g (assoc-root aa) name) )
        (assoc-clr g name) )

(defun dgraph-succ (g name) <g name 0>)

(defun dgraph-prec (g name) <g name 1>)

(defun dgraph-succ-count (g name) (length <g name 0>))

(defun dgraph-prec-count (g name) (length <g name 1>))

(defun dgraph-succ-ext (g name)
        (dgraph-succ-prec-ext g name 0) )

(defun dgraph-prec-ext (g name)
        (dgraph-succ-prec-ext g name 1) )

(defun dgraph-succ-prec-ext (g name w) net dgraph-succ-prec-ext)
(defnet dgraph-succ-prec-ext (g name w @a)
        (deflocal q n)

        (assocp g)
        (<> <g name> undef)
        (set @a (assoc))
        (set q (queue))
        (queue-put q name)
        (repeat (for name in <g (queue-get q) w> do
                        (set n (car name))
                        (if (= <@a n> undef)
                        then    (set <@a n> true)
                                (queue-put q n) ))
                until (= (length q) 0) ))

(defnet dgraph-renamenode (g oldname newname)
        (deflocal a i aa)

        (assocp g)
        (set a <g oldname>)
        (<> a undef)
        (= <g newname> undef)
        (set <g newname> a)
        (assoc-clr g oldname)
        (for i in <a 0> do
                (if (<> (car i) oldname)
                then    (set aa <g (car i) 1>)
                        (set <aa newname> <aa oldname>)
                        (assoc-clr aa oldname) ))
        (for i in <a 1> do
                (if (<> (car i) oldname)
                then    (set aa <g (car i) 0>)
                        (set <aa newname> <aa oldname>)
                        (assoc-clr aa oldname) ))
        (set i <a 0 oldname>)
        (if (<> i undef)
        then    (set <a 0 newname> i)
                (assoc-clr <a 0> oldname) )
        (set i <a 1 oldname>)
        (if (<> i undef)
        then    (set <a 1 newname> i)
                (assoc-clr <a 1> oldname) ))

(defun dgraph-getnode (g name) net dgraph-getnode)
(defnet dgraph-getnode (g name @a)
        (assocp g)
        (set @a <g name>)
        (if (= @a undef)
        then    (dgraph-mknode g name undef)
                (set @a <g name>) ))

(defnet dgraph-setnodeval (g name val)
        (deflocal a)

        (set a (dgraph-getnode g name))
        (<> a undef)
        (set <a 2> val) )

(defun dgraph-getnodeval (g name) net dgraph-getnodeval)
(defnet dgraph-getnodeval (g name @val)
        (deflocal a)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set @val <a 2>) )

(defnet dgraph-setnodeattr (g name key val)
        (deflocal a)

        (set a (dgraph-getnode g name))
        (<> a undef)
        (set <a 3 key> val) )

(defun dgraph-getnodeattr (g name key) net dgraph-getnodeattr)
(defnet dgraph-getnodeattr (g name key @val)
        (deflocal a)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set @val <a 3 key>) )

;;;
;;; crea un nuovo arco
;;;

(defnet dgraph-mkedge (g name1 name2 val)
        (dgraph-mkedge-low g name1 name2 val false) )

;;;
;;; crea un nuovo arco purché tale creazione non introduca un ciclo
;;;

(defnet dgraph-mkedge-acyclic (g name1 name2 val)
        (dgraph-mkedge-low g name1 name2 val true) )

;;;
;;; crea un nuovo arco - low level
;;;

(defnet dgraph-mkedge-low (g name1 name2 val acyclic)
        (deflocal a1 a2 a)

        (set a1 (dgraph-getnode g name1))
        (<> a1 undef)
        (set a2 (dgraph-getnode g name2))
        (<> a2 undef)
        (set a1 <a1 0>)
        (set a2 <a2 1>)
        (= <a1 name2> undef)
        (if acyclic
        then    (<> name1 name2)
                (= <(dgraph-succ-ext g name2) name1> undef) )
        (set a (array 2))
        (set <a 0> val)
        (set <a 1> (assoc)) ; attributi dell`arco
        (set <a1 name2> a)
        (set <a2 name1> true) )

;;;
;;; rimuove un arco esistente
;;;

(defnet dgraph-rmedge (g name1 name2)
        (deflocal a1 a2)

        (assocp g)
        (set a1 <g name1>)
        (<> a1 undef)
        (set a2 <g name2>)
        (<> a2 undef)
        (set a1 <a1 0>)
        (set a2 <a2 1>)
        (<> <a1 name2> undef)
        (assoc-clr a1 name2)
        (assoc-clr a2 name1) )

;;;
;;; rimuove tutti gli archi in uscita da un nodo
;;;

(defnet dgraph-rmedges-succ (g name)
        (deflocal a)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set a <a 0>)
        (while (> (length a) 0) do
                (dgraph-rmedge g name (assoc-root a)) ))

;;;
;;; rimuove tutti gli archi in ingresso a un nodo
;;;

(defnet dgraph-rmedges-prec (g name)
        (deflocal a)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set a <a 1>)
        (while (> (length a) 0) do
                (dgraph-rmedge g (assoc-root a) name) ))

(defnet dgraph-setedgeval (g name1 name2 val)
        (deflocal a)

        (set a (dgraph-getnode g name1))
        (<> a undef)
        (set <a 0 name2 0> val) )

(defun dgraph-getedgeval (g name1 name2)
        <g name1 0 name2 0> )

(defnet dgraph-setedgeattr (g name1 name2 key val)
        (deflocal a)

        (set a (dgraph-getnode g name1))
        (<> a undef)
        (set <a 0 name2 1 key> val) )

(defun dgraph-getedgeattr (g name1 name2 key)
        <g name1 0 name2 1 key> )

; rende una copia di un grafo

(defun dgraph-clone (g) net dgraph-clone)
(defnet dgraph-clone (g @g)
        (deflocal i j name a)

        (assocp g)
        (set @g (dgraph-create))
        (for i in g do
                (set name (car i))
                (set a (cdr i))
                (for j in <a 0> do
                        (dgraph-mkedge @g name (car j) <(cdr j) 0>)
                        (dgraph-clone-attr <(cdr j) 1> <@g name 0 (car j) 1>) )
                (opt (dgraph-mknode @g name undef))
                (set i <@g name>)
                (set <i 2> <a 2>)
                (dgraph-clone-attr <a 3> <i 3>) ))

(defnet dgraph-clone-attr (ai ao)
        (deflocal i)

        (for i in ai do
                (set <ao (car i)> (cdr i)) ))

; rende una copia del più grande sottografo connesso
; contenente un nodo

(defun dgraph-clone-sub (g name) net dgraph-clone-sub)
(defnet dgraph-clone-sub (g name @g)
        (deflocal q v a j n)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set @g (dgraph-create))
        (set q (queue))
        (set v (assoc))
        (set <v name> true)
        (repeat (for j in <a 0> do
                        (set n (car j))
                        (if (= <v n> undef)
                        then    (queue-put q n)
                                (set <v n> true) )
                        (dgraph-mkedge @g name n <(cdr j) 0>)
                        (dgraph-clone-attr <(cdr j) 1> <@g name 0 n 1>) )
                (for j in <a 1> do
                        (set n (car j))
                        (if (= <v n> undef)
                        then    (queue-put q n)
                                (set <v n> true) ))
                (opt (dgraph-mknode @g name undef))
                (set j <@g name>)
                (set <j 2> <a 2>)
                (dgraph-clone-attr <a 3> <j 3>)
                until (= (length q) 0)
                (set name (queue-get q))
                (set a <g name>) ))

; simile al precedente però fa in modo che ogni nodo
; contenuto nel sottografo sia raggiungibile da name
; (o viceversa)

(defun dgraph-clone-sub-weak (g name) net dgraph-clone-sub-weak)
(defnet dgraph-clone-sub-weak (g name @g)
        (deflocal q v a nn aa j n)

        (assocp g)
        (set a <g name>)
        (<> a undef)
        (set @g (dgraph-create))
        (set q (queue))
        (set v (assoc))
        (set <v name> true)
        (set nn name)
        (set aa a)
        (repeat (for j in <aa 0> do
                        (set n (car j))
                        (if (= <v n> undef)
                        then    (queue-put q n)
                                (set <v n> true) )
                        (dgraph-mkedge @g nn n <(cdr j) 0>)
                        (dgraph-clone-attr <(cdr j) 1> <@g nn 0 n 1>) )
                (opt (dgraph-mknode @g nn undef))
                (set j <@g nn>)
                (set <j 2> <aa 2>)
                (dgraph-clone-attr <aa 3> <j 3>)
                until (= (length q) 0)
                (set nn (queue-get q))
                (set aa <g nn>) )
        (set nn name)
        (set aa a)
        (repeat (for j in <aa 1> do
                        (set n (car j))
                        (if (= <v n> undef)
                        then    (queue-put q n)
                                (set <v n> true) )
                        (dgraph-mkedge @g n nn <g n 0 nn 0>)
                        (dgraph-clone-attr <g n 0 nn 1> <@g n 0 nn 1>) )
                (opt (dgraph-mknode @g nn undef))
                (set j <@g nn>)
                (set <j 2> <aa 2>)
                (dgraph-clone-attr <aa 3> <j 3>)
                until (= (length q) 0)
                (set nn (queue-get q))
                (set aa <g nn>) ))

; rende un array contenente i sottografi connessi

(defun dgraph-partition (g) net dgraph-partition)
(defnet dgraph-partition (g @a)
        (deflocal sub i)

        (set g (dgraph-clone g))
        (assocp g)
        (set @a (array 0))
        (while (> (length g) 0) do
                (set sub (dgraph-clone-sub g (assoc-root g)))
                (array-append @a sub)
                (for i in sub do
                        (dgraph-rmnode g (car i)) )))

;;;
;;; booleano: true sse il grafo è connesso
;;;

(defun dgraph-is-connected (g) net dgraph-is-connected)
(defnet dgraph-is-connected (g @ris)
        (deflocal l)

        (assocp g)
        (set l (length g))
        (if (= l 0)
        then    (set @ris true)
        else    (set @ris (= (length (dgraph-clone-sub g (assoc-root g))) l)) ))

;;;
;;; rende la radice se il grafo è un albero, altrimenti undef
;;; FIXME forse si può fare meglio
;;;

(defun dgraph-root-if-is-tree (g) net dgraph-root-if-is-tree)
(defnet dgraph-root-if-is-tree (g @r)
        (deflocal n)

        (for n in g do
                (case (length (dgraph-prec g (car n))) of
                        0       (seq    (= @r undef)
                                        (set @r (car n)) )
                        1       (success)
                        default (fail) ))
        (<> @r undef)
        (= (length (dgraph-succ-ext g @r)) (- (length g) 1)) )

;;;
;;; input: g (digrafo non vuoto), p (nodo di g);
;;; i valori degli archi di g devono essere razionali positivi;
;;; output: albero contenente tutti i nodi raggiungibili da p in un cammino
;;; di costo minimo (il costo del cammino da p al nodo è nell`unico arco
;;; entrante nel nodo)
;;;

(defun dgraph-dijkstra (g p) net dgraph-dijkstra)
(defnet dgraph-dijkstra (g p @g)
        (deflocal q d n m dnm i)

        (set @g (dgraph-create))
        (set q (fibo))
        (dgraph-dijkstra-update @g q p 0 undef)
        (repeat (set d (fibo-extract q))
                (set n (fibo-obj d))
                (set d (fibo-key d))
                (for i in (dgraph-succ g n) do
                        (set m (car i))
                        (set dnm (dgraph-getedgeval g n m))
                        (rationalp dnm)
                        (> dnm 0)
                        (dgraph-dijkstra-update @g q m (+ d dnm) n) )
                until (= (length q) 0) )
        (for i in @g do
                (set d <(cdr i) 2>)
                (set n <d 1>)
                (if (<> n undef)
                then    (dgraph-mkedge @g n (car i) (fibo-key <d 0>)) )))

(defnet dgraph-dijkstra-update (g q node dist prev)
        (deflocal a)

        (set a (dgraph-getnodeval g node))
        (if (= a undef)
        then    (set a (array 2))
                (set <a 0> (fibo-insert q dist node))
                (set <a 1> prev)
                (dgraph-mknode g node a)
        else    (if (< dist (fibo-key <a 0>))
                then    (fibo-decrease-key q <a 0> dist)
                        (set <a 1> prev) )))

;;;
;;; input: g (digrafo non vuoto), p (nodo di g);
;;; i valori degli archi di g devono essere razionali (anche negativi);
;;; output: albero contenente tutti i nodi raggiungibili da p in un cammino
;;; di costo minimo (il costo del cammino da p al nodo è nell`unico arco
;;; entrante nel nodo)
;;;

(defun dgraph-bellman-ford (g p) net dgraph-bellman-ford)
(defnet dgraph-bellman-ford (g p @g)
        (deflocal n nn d i cnt unchanged)

        (set @g (dgraph-create))
        (dgraph-bellman-ford-update @g p 0 undef)
        (set cnt (length g))
        (repeat (set unchanged true)
                (for n in @g do
                        (set nn (car n))
                        (set d <(cdr n) 2 0>)
                        (for i in (dgraph-succ g nn) do
                                (opt    (dgraph-bellman-ford-update @g (car i) (+ d (dgraph-getedgeval g nn (car i))) nn)
                                        (set unchanged false) )))
                until unchanged
                (dec cnt)
                ; se cnt == 0 allora abbiamo rilevato un ciclo di lunghezza negativa
                ; e rendiamo undef
                (> cnt 0) )
        (for i in @g do
                (set d <(cdr i) 2>)
                (set n <d 1>)
                (if (<> n undef)
                then    (dgraph-mkedge @g n (car i) <d 0>) )))

(defnet dgraph-bellman-ford-update (g node dist prev)
        (deflocal a)

        (set a (dgraph-getnodeval g node))
        (if (= a undef)
        then    (set a (array 2))
                (dgraph-mknode g node a)
        else    (< dist <a 0>) )
        (set <a 0> dist)
        (set <a 1> prev) )

;;;
;;; genera un digrafo random
;;;

(defun dgraph-random (n l) net dgraph-random)
(defnet dgraph-random (n l @g)
        (deflocal i)

        (integerp n)
        (integerp l)
        (in n 2 .. 26)
        (in l 1 .. 500)
        (set @g (dgraph-create))
        (for i in 1 .. n do
                (dgraph-mknode @g (int->char (+ 64 i)) undef) )
        (while (> l 0) do
                (opt    (dgraph-mkedge @g (int->char (+ 65 (random n)))
                                          (int->char (+ 65 (random n)))
                                          (+ 1 (random 10)) )
                        (dec l) )))

;;;
;;; genera un sorgente dot
;;;

(defun dgraph->dot (g) net dgraph->dot)
(defnet dgraph->dot (g @dot)
        (deflocal a n nn s m v sep)

        (assocp g)
        (set @dot "digraph G {\n" \
                ;  "  layout=dot;\n" \
                ;  "  rankdir=LR;\n" \
                  "  layout=neato;\n" \
                  "  esep=0.4;\n" \
                  "  splines=true;\n" \
                  "  overlap=voronoi;\n" \
                  "  overlap_shrink=true;\n"
                  )
        (set a (assoc))
        (for n in g do
                (set nn (car n))
                (set s (+ "n" (for-pos)))
                (set <a nn> s)
                (inc @dot "  " s " [label=" (dgraph->dot-quote nn))
                (for v in <(cdr n) 3> do
                        (inc @dot "," (car v) "=" (dgraph->dot-value (cdr v))) )
                (inc @dot "];\n") )
        (for n in g do
                (set nn (car n))
                (set s <a nn>)
                (for m in (dgraph-succ g nn) do
                        (inc @dot "  " s " -> " <a (car m)> "[")
                        (set sep "")
                        (if (and (= <(cdr m) 1 "label"> undef)
                                 (= <(cdr m) 1 "taillabel"> undef)
                                 (= <(cdr m) 1 "headlabel"> undef) )
                        then    (set v <(cdr m) 0>)
                                (if (<> v undef)
                                then    (inc @dot "label=" (dgraph->dot-value v))
                                        (set sep ",") ))
                        (for v in <(cdr m) 1> do
                                (inc @dot sep (car v) "=" (dgraph->dot-value (cdr v)))
                                (set sep ",") )
                        (inc @dot "];\n") ))
        (inc @dot "}\n") )

(defun dgraph->dot-quote (s)
        (+ "\"" (find-and-replace (str-split s 20) "\n" "\\n") "\"") )

(defun dgraph->dot-value (v)
        (+ "\"" (if (colorp v) (dgraph->dot-color v) v) "\"") )

(defun dgraph->dot-color (color)
        (+ "#" (dgraph->dot-color-byte (pix-color-red color))
               (dgraph->dot-color-byte (pix-color-green color))
               (dgraph->dot-color-byte (pix-color-blue color))
               (dgraph->dot-color-byte (pix-color-alpha color)) ))

(defun dgraph->dot-color-byte (b) (sprint (hexdigit0 (div b 0x10)) (hexdigit0 (% b 0x10))))

;;;
;;; genera un`immagine del grafo g
;;;

(defun dgraph->pix (g)
        (ag-dot2pix (dgraph->dot g)) )

;;;
;;; salva su path un`immagine del grafo g
;;;

(defnet dgraph-save-png (g path)
        (deflocal pix)

        (set pix (dgraph->pix g))
        (pixp pix)
        (alt    (pix-save-png pix path)
                (seq    (close pix)
                        (fail) ))
        (close pix) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; obsoleto (usare ag-dot2pix)

;(defun dot->pix (dot) net dot->pix)
;(defnet dot->pix (dot @pix)
;        (deflocal tmp)

;        (stringp dot)
;        (mktmpdir tmp)
;        (alt    (seq    (str-save (+ tmp "/a.dot") dot)
;                        (system "dot -Tpng " (+ tmp "/a.dot") " > " (+ tmp "/a.png") " 2>/dev/null")
;                        (set @pix (pix-load (+ tmp "/a.png")))
;                        (pixp @pix)
;                        (rmhier tmp) )
;                (seq    (rmhier tmp)
;                        (fail) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sqlite3-structure (db count)
        (ag-dot2pix (sqlite3-structure-dot db count)) )

(defun sqlite3-structure-dot (db count) net sqlite3-structure-dot)
(defnet sqlite3-structure-dot (db count @s)
        (deflocal asc q l s i j table field command)

        (set @s "")
        (set asc (assoc))
        (set q (queue))
        (for l in (sqlite3-exec db "SELECT * FROM sqlite_master WHERE type='table'") do
                (set s l)
                (list-pop s i)
                (= i "table")
                (list-pop s table)
                (list-pop s i)
                (= table i)
                (list-pop s i)
                (list-pop s command)
                (rmatch remove command ")")
                (lmatch case remove command "CREATE TABLE ")
                (lmatch remove command (+ "\"" table "\"") table)
                (lmatch remove command "(")
                (inc command ",")
                (set <asc table> (assoc))
                (set <asc table "fields"> (queue))
                (set <asc table "fieldattr"> (assoc))
                (set <asc table "cp"> (length q))
                (queue-put q table)
                (opt*   (search "," command i)
                        (set s (sub 0 i command))
                        (set command (sub (+ i 1) (maxint) command))
                        (alt    (seq    (search " " s i)
                                        (set field (sub 0 i s))
                                        (set s (sub (+ i 1) (maxint) s)) )
                                (seq    (set field s)
                                        (set s "") ))
                        (queue-put <asc table "fields"> field)
                        (set <asc table "fieldattr" field> (array default false 5))
                        (opt*   (alt    (lmatch case remove s "integer")
                                        (seq    (lmatch case remove s "char")
                                                (set <asc table "fieldattr" field 0> true) )
                                        (seq    (lmatch case remove s "primary key")
                                                (set <asc table "fieldattr" field 1> true)
                                                (set <asc table "fieldattr" field 3> true)
                                               (set <asc table "fieldattr" field 4> true) )
                                        (seq    (lmatch case remove s "unique")
                                                (set <asc table "fieldattr" field 2> true)
                                                (set <asc table "fieldattr" field 3> true) )
                                        (seq    (lmatch case remove s "not null")
                                                (set <asc table "fieldattr" field 4> true) ))
                                (ltrim s) )
                        (if (<> s "")
                        then    (print "errore: non capisco la sintassi del comando (table)" nl)
                                (fail) )))
        (for l in (sqlite3-exec db "SELECT * FROM sqlite_master WHERE type='index'") do
                (set s l)
                (list-pop s i)
                (= i "index")
                (list-pop s i)
                (list-pop s table)
                (list-pop s i)
                (list-pop s command)
                (if (stringp command)
                then    (alt    (seq    (lmatch case remove command "CREATE INDEX ")
                                        (lmatch remove command table)
                                        (lmatch remove command "_")
                                        (search " " command i)
                                        (set field (sub 0 i command))
                                        (set command (sub (+ i 1) (maxint) command))
                                        (lmatch remove command "ON ")
                                        (lmatch remove command table)
                                        (lmatch remove command "(")
                                        (lmatch remove command field)
                                        (= command ")")
                                        (set <asc table "fieldattr" field 3> true) )
                                (seq    (print "errore: non capisco la sintassi del comando (index)" nl)
                                        (fail) ))))
        (inc @s "digraph g {" nl
                "layout=neato;" nl
                "overlap=false;" nl
                "splines=true;" nl
                "graph [" nl "ranksep=1.5;rankdir=\"TB\"" nl
                "];" nl )
        (set s (queue))
        (for table in q do
                (inc @s "node" <asc table "cp"> " [shape=record,label=\"{" table)
                (if count
                then    (inc @s " (" (str->num <(sqlite3-exec db "SELECT count(*) FROM " table) 0 0>) ")") )
                (inc @s "|{{")
                (for field in <asc table "fields"> do
                        (if (lmatch field "cp_")
                        then    (set j (sub 3 (maxint) field))
                                (opt    (search "_" j i (maxint))
                                        (integerp (str->num (sub (+ i 1) (maxint) j)))
                                        (set j (sub 0 i j)) )
                                (queue-put s (+ "node" <asc table "cp"> ":f" (for-pos) " -> node" <asc j "cp">))
                                (set j (+ "^(" (sub 3 (maxint) field) ")"))
                        else    (set j field) )
                        (inc @s (if (> (for-pos) 0) "|" "") (if (<> j field) (+ "<f" (for-pos) ">") "") j) )
                (inc @s "}|{")
                (for field in <asc table "fields"> do
                        (set i (if <asc table "fieldattr" field 0> "c" "i"))
                        (if <asc table "fieldattr" field 1>
                        then    (inc i "p") )
                        (if <asc table "fieldattr" field 2>
                        then    (inc i "u") )
                        (if <asc table "fieldattr" field 3>
                        then    (inc i "x") )
                        (if (not <asc table "fieldattr" field 4>)
                        then    (inc i "n") )
                        (inc @s (if (> (for-pos) 0) "|" "") i) )
                (inc @s "}}}\"];" nl) )
        (for i in s do
                (inc @s i nl) )
        (inc @s "}" nl) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun homepath (p) (+ (rtrim (getenv "HOME") '/') "/" (ltrim p '/')))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defglobal _imdb)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun imdb-path () (homepath ".treep/imdb.old"))
(defun imdb-db-path () (+ (imdb-path) "/imdb.db"))

(defun imdb () net imdb-db)
(defnet imdb-db (@db)
        (if (= _imdb undef)
        then    (alt    (seq    (pathexists (imdb-db-path))
                                (set _imdb (sqlite3-open (imdb-db-path)))
                                (<> _imdb undef) )
                        (seq    (fprint (stderr) "apertura imdb fallita" nl)
                                (exit -1) )))
        (set @db _imdb) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun title->id (title)
        (str->num <(sqlite3-exec (imdb)
                "SELECT id FROM movies WHERE title='"
                (sqlite3-escape-strings title) "'" ) 0 0>))

(defun id->title (movie-id)
        <(sqlite3-exec (imdb)
                "SELECT title FROM movies WHERE id=" movie-id ) 0 0> )

(defun name->id (name)
        (str->num <(sqlite3-exec (imdb)
                "SELECT id FROM people WHERE name='"
                (sqlite3-escape-strings name) "'" ) 0 0>))

(defun id->name (people-id)
        <(sqlite3-exec (imdb)
                "SELECT name FROM people WHERE id=" people-id) 0 0> )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun words->movies (words max) net words->movies)
(defnet words->movies (words max @l)
        (words->movies-basic false words max @l) )

(defun exact-words->movies (words max) net exact-words->movies)
(defnet exact-words->movies (words max @l)
        (words->movies-basic true words max @l) )

(defnet words->movies-basic (exact words max @l)
        (deflocal query i w)

        (if (= (length words) 0)
        then    (set @l nil)
        else    (set query "")
                (for i in words do
                        (set w (utf8-tolower (if (assocp words) (car i) i)))
                        (set query (+ "SELECT movie_id FROM movies_index"
                                      " WHERE word" (if exact "" ">") "='"
                                      (sqlite3-escape-strings w) "'"
                                      (if exact "" (+ " AND word<'"
                                      (sqlite3-escape-strings (str-succ w))
                                      "'" ))
                                      (if (= query "") "" " INTERSECT ")
                                      query )))
                (if (<> max undef)
                then    (set query (+ query " LIMIT " max)) )
                (set @l (sqlite3-exec (imdb) query)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun title-report (movie-id) net title-report)
(defnet title-report (movie-id @s)
        (deflocal t i)

        (set @s "")
        (set t <(sqlite3-exec (imdb) "SELECT title,year,rank,votes,distribution FROM movies WHERE id=" movie-id) 0>)
        (if (<> t undef)
        then    (set @s (+ @s
               "Titolo" nl
               "------" nl
               nl
               <t 0> " - " <t 1> nl )))

        (for i in (sqlite3-exec (imdb) "SELECT title,note FROM aka_titles WHERE movie_id=" movie-id) do
                (set @s (+ @s
                "    " <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl )))

        (if (<> <t 2> undef)
        then    (set @s (+ @s
               nl
               "Ratings" nl
               "-------" nl
               nl
               "Rank = " <t 2> ", voti = " <t 3> " (" <t 4> ")" nl )))

        (set i (sqlite3-exec (imdb) "SELECT country FROM countries WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Paese" nl
               "-----" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT language,note FROM language WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Lingua" nl
               "------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM color_info WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Colore" nl
               "------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM sound_mix WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Suono" nl
               "-----" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM locations WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Locations" nl
               "---------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT type,info,note FROM technical WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Dati tecnici" nl
               "------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> " = " <i 1> (if (= <i 2> undef) "" (+ " (" <i 2> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT running_time,country,note FROM running_times WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Durata" nl
               "------" nl
               nl ))
               (for i in i do (set @s (+ @s
               <i 0> " min" (if (= <i 1> undef) "" (+ " (" <i 1> ")")) (if (= <i 2> undef) "" (+ " (" <i 2> ")")) nl )) ))

        (set i (sqlite3-exec (imdb) "SELECT genre FROM genres WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Genere" nl
               "------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT tagline FROM taglines WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Taglines" nl
               "--------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT keyword FROM keywords WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Parole chiave" nl
               "-------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name FROM people,directors WHERE movie_id=" movie-id " AND id=people_id"))
        ;(set i (sqlite3-exec (imdb) "SELECT name,note FROM people,directors WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Regista" nl
               "-------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,writers WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Soggetto/Sceneggiatura" nl
               "----------------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT type,info FROM literature WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Literature" nl
               "----------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> " = " <i 1> nl ))))

        (set i (+ (sqlite3-exec (imdb) "SELECT name,character_name,note FROM people,cast WHERE movie_id=" movie-id " AND id=people_id AND billing_position IS NOT NULL ORDER BY billing_position")
                  (sqlite3-exec (imdb) "SELECT name,character_name,note FROM people,cast WHERE movie_id=" movie-id " AND id=people_id AND billing_position IS NULL") ))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Cast" nl
               "----" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0>
               (if (= <i 1> undef) "" (+ " [" <i 1> "]"))
               (if (= <i 2> undef) "" (+ " (" <i 2> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,author FROM plot WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Trama" nl
               "-----" nl ))
                (for i in i do (set @s (+ @s
               nl
               <i 0> nl
               (if (= <i 1> undef) "" (+ "[by " <i 1> "]" nl)) ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,composers WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Musiche" nl
               "-------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,editors WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Montaggio" nl
               "---------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,costume_designers WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Costumi" nl
               "-------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,producers WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Produttori" nl
               "----------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,production_designers WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Production designers" nl
               "--------------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,cinematographers WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Cinematographers" nl
               "----------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT name,note FROM people,miscellaneous WHERE movie_id=" movie-id " AND id=people_id"))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Altre persone" nl
               "-------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM special_effects_companies WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Effetti speciali" nl
               "----------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM production_companies WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Case di produzione" nl
               "------------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM distributors WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Distribuzione" nl
               "-------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM miscellaneous_companies WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Misc companies" nl
               "--------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info,note FROM certificates WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Certificates" nl
               "------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> (if (= <i 1> undef) "" (+ " (" <i 1> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info FROM mpaa_ratings_reasons WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "MPAA ratings reasons" nl
               "--------------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT place,date,note FROM release_dates WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Date di uscita" nl
               "--------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               (if (= <i 0> undef) "" (+ <i 0> ": ")) (str->date <i 1>) (if (= <i 2> undef) "" (+ " (" <i 2> ")")) nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info FROM trivia WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Curiosita'" nl
               "----------" nl ))
                (for i in i do (set @s (+ @s
               nl
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info FROM crazy_credits WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Crazy Credits" nl
               "-------------" nl ))
                (for i in i do (set @s (+ @s
               nl
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT goof_type,info FROM goofs WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Errori" nl
               "------" nl ))
                (for i in i do (set @s (+ @s
               nl
               "* errore di tipo " <i 0> nl
               <i 1> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT info FROM alternate_versions WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Versioni alternative" nl
               "--------------------" nl ))
                (for i in i do (set @s (+ @s
               nl
               <i 0> nl ))))

        (set i (sqlite3-exec (imdb) "SELECT type,info FROM business WHERE movie_id=" movie-id))
        (if (<> i nil)
        then    (set @s (+ @s
               nl
               "Business" nl
               "--------" nl
               nl ))
                (for i in i do (set @s (+ @s
               <i 0> " = " <i 1> nl ))))

        (set i (+ (sqlite3-exec (imdb) "SELECT title,link_type,'' FROM movies,movie_links WHERE movie_id1=" movie-id " AND id=movie_id2")
                  (sqlite3-exec (imdb) "SELECT title,link_type,'^-1' FROM movies,movie_links WHERE movie_id2=" movie-id " AND id=movie_id1") ))
        (if (<> i nil)
        then    (set @s (+ @s nl
               "Collegamenti" nl
               "------------" nl
               nl ))
                (for i in i do (set @s (+ @s
               "(" <i 1> ")" <i 2> " " <i 0> nl ))))

        (skip) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun imdbtitle->code (title) net imdbtitle->code)
(defnet imdbtitle->code (title @code)
        (deflocal imdb-code done year s q i)

        (set imdb-code (title->id title))
        (<> imdb-code undef)
        (set q (queue))
        (imdbtitle->code-split-and-store title year q)
        (find-and-replace title " " "%20")
        (set s (download-as-string (+ "http://www.imdb.com/search/title?release_date="
                year "," year "&title=" title )))
        (for i in (sqlite3-exec (imdb)
                "SELECT title FROM aka_titles"
                " WHERE movie_id=" imdb-code ) do
                (set title <i 0>)
                (opt (imdbtitle->code-split-and-store title year q)) )
        (set done false)
        (for title in q do
                (opt    (search (+ "/\" title=\"" title " (") s i)
                        (set s (sub 0 i s))
                        (set done true) )
                until done )
        (= done true)
        (search "<a href=\"/title/tt" s i (maxint))
        (set @code (str->num (sub (+ i 18) (maxint) s)))
        (<> @code undef) )

(defnet imdbtitle->code-split-and-store (@title @year q)
        (deflocal i title)

        (opt    (rmatch remove @title "(V)" "(TV)")
                (rtrim @title) )
        (rmatch remove @title ")")
        (rtrim @title 'I' '/')
        (search " (" @title i (maxint))
        (set @year (str->num (sub (+ i 2) (maxint) @title)))
        (<> @year undef)
        (set @title (sub 0 i @title))
        (opt    (lmatch remove @title "\"")
                (rmatch remove @title "\"") )
        ; attenzione: da qui in poi @title non va modificato
        (set title @title)
        (find-and-replace title "&" "&#x26;")
        (find-and-replace title "'" "&#x27;")
        (find-and-replace title (iso->utf8 "Å") "&#xC5;")
        (find-and-replace title (iso->utf8 "à") "&#xE0;")
        (find-and-replace title (iso->utf8 "â") "&#xE2;")
        (find-and-replace title (iso->utf8 "å") "&#xE5;")
        (find-and-replace title (iso->utf8 "É") "&#xC9;")
        (find-and-replace title (iso->utf8 "è") "&#xE8;")
        (find-and-replace title (iso->utf8 "é") "&#xE9;")
        (find-and-replace title (iso->utf8 "ë") "&#xEB;")
        (find-and-replace title (iso->utf8 "ì") "&#xEC;")
        (find-and-replace title (iso->utf8 "í") "&#xED;")
        (find-and-replace title (iso->utf8 "Ò") "&#xD2;")
        (find-and-replace title (iso->utf8 "ò") "&#xF2;")
        (find-and-replace title (iso->utf8 "ó") "&#xF3;")
        (find-and-replace title (iso->utf8 "ô") "&#xF4;")
        (find-and-replace title (iso->utf8 "ù") "&#xF9;")
        (find-and-replace title (iso->utf8 "ü") "&#xFC;")
        (find-and-replace title (iso->utf8 "ñ") "&#xF1;")
        (queue-put q title) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

