;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun linux () (search case "linux" (uname)))
(defun ms-windows () (or (cygwin) (mingw)))
(defun mac-osx () (darwin))
(defun cygwin () (search case "cygwin" (uname)))
(defun mingw () (search case "mingw" (uname)))
(defun darwin () (search case "darwin" (uname)))
(defun raspberry () (search case "linux arm" (uname)))

(defun clinux () (search case "linux" (cuname)))
(defun cms-windows () (or (ccygwin) (cmingw)))
(defun cmac-osx () (cdarwin))
(defun ccygwin () (search case "cygwin" (cuname)))
(defun cmingw () (search case "mingw" (cuname)))
(defun cdarwin () (search case "darwin" (cuname)))
(defun craspberry () (search case "linux arm" (cuname)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet truep (cond) (= cond true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; il modo piÃ¹ semplice di clonare un oggetto

(defun clone-obj (obj) net clone-obj)
(defnet clone-obj (obj @obj)
        (deflocal raw)

        (set raw (compress obj 0))
        (set @obj (uncompress raw))
        (close raw) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun gcry-md5sum (obj) (gcry-md-hash (cmacro GCRY_MD_MD5) obj))
(defun gcry-sha1sum (obj) (gcry-md-hash (cmacro GCRY_MD_SHA1) obj))
(defun gcry-sha256sum (obj) (gcry-md-hash (cmacro GCRY_MD_SHA256) obj))
(defun gcry-md5sum-fast (obj) (gcry-md-hash-fast (cmacro GCRY_MD_MD5) obj))
(defun gcry-sha1sum-fast (obj) (gcry-md-hash-fast (cmacro GCRY_MD_SHA1) obj))
(defun gcry-sha256sum-fast (obj) (gcry-md-hash-fast (cmacro GCRY_MD_SHA256) obj))
(defun gcry-fmd5sum (path) (gcry-md-hash-file (cmacro GCRY_MD_MD5) path))
(defun gcry-fsha1sum (path) (gcry-md-hash-file (cmacro GCRY_MD_SHA1) path))
(defun gcry-fsha256sum (path) (gcry-md-hash-file (cmacro GCRY_MD_SHA256) path))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet invert-test (net param)
        (deflocal i)

        (alt    (seq    (call net param)
                        (set i true) )
                (set i false) )
        (not i) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cal->joule (x) (* x 4.184))
(defun joule->cal (x) (/ x 4.184))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path->lines (path) net path->lines)
(defnet path->lines (path @a) (path->lines-low path @a false))

(defun path->lines-clean (path) net path->lines-clean)
(defnet path->lines-clean (path @a) (path->lines-low path @a true))

(defnet path->lines-low (path @a clean)
        (deflocal f l)

        (set f (fopenro path))
        (<> f undef)
        (set @a (array 0))
        (repeat (set l (freadline f))
                until (= l undef)
                (if clean
                then    (ltrim l ' ' '\t')
                        (rtrim l ' ' '\t') )
                (array-append @a l) )
        (close f) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun array-copy (a) net array-copy)
(defnet array-copy (a @a)
        (deflocal n i)

        (set n (length a))
        (set @a (array n))
        (for i in 0 .. (- n 1) do
                (set <@a i> <a i>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet paths-have-the-same-size (path1 path2)
        (deflocal size)

        (paths-have-the-same-size-low path1 path2 size) )

(defnet paths-have-the-same-size-low (path1 path2 @size)
        (set @size (fsize path1))
        (integerp @size)
        (>= @size 0)
        (= @size (fsize path2)) )

(defun paths-have-the-same-size (path1 path2) net paths-have-the-same-size-net)
(defnet paths-have-the-same-size-net (path1 path2 @res)
        (alt    (seq    (paths-have-the-same-size path1 path2)
                        (set @res true) )
                (set @res false) ))

(defnet paths-have-the-same-content (path1 path2 @samesize @dbit)
        (deflocal rem f1 f2 raw1 raw2 i)

        (alt    (seq    (paths-have-the-same-size-low path1 path2 rem)
                        (set f1 (fopenro path1))
                        (<> f1 undef)
                        (set f2 (fopenro path2))
                        (if (= f2 undef)
                        then    (close f1)
                                (fail) )
                        (set raw1 (raw 65536))
                        (set raw2 (raw 65536))
                        (set @dbit 0)
                        (opt*   (> rem 0)
                                (set i (raw-read raw1 f1))
                                (= i (raw-read raw2 f2))
                                (dec rem i)
                                (inc @dbit (raw-cmp raw1 raw2 i)) )
                        (close raw1 raw2 f1 f2)
                        (set @samesize true) )
                (seq    (set @samesize false)
                        (clr @dbit) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet path-content-is-valid (path)
        (deflocal fail ext)

        (set fail false)
        (set ext (path-suggest-extension path))
        (alt    (seq    (in ext [ "rar" "cbr" ])
                        (alt    (path-content-is-valid-rar path)
                                (set fail true) ))
                (seq    (in ext [ "zip" "cbz" "epub" "odt" "docx" "apk" ])
                        (alt    (path-content-is-valid-zip path)
                                (set fail true) ))
                (seq    (in ext [ "xz" ])
                        (alt    (path-content-is-valid-xz path)
                                (set fail true) ))
                (seq    (in ext [ "flac" ])
                        (alt    (path-content-is-valid-flac path)
                                (set fail true) ))
                (seq    (in ext [ "wv" ])
                        (alt    (path-content-is-valid-wv path)
                                (set fail true) ))
                (seq    (in ext [ "avi" "mkv" "mp4" "flv" "ape" ])
                        (alt    (path-content-is-valid-ffmpeg path)
                                (set fail true) ))
                (seq    (in ext [ "jpg" ])
                        (alt    (path-content-is-valid-jpg path)
                                (set fail true) ))
                (seq    (in ext [ "png" ])
                        (alt    (path-content-is-valid-png path)
                                (set fail true) ))
                (seq    (in ext [ "pdf" ])
                        (alt    (path-content-is-valid-pdf path)
                                (set fail true) ))
                (set fail true) )
        (not fail) )

(defnet path-content-is-valid-rar (path)
        (system "rar t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-zip (path)
        (system "7z t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-xz (path)
        (system "xz -t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-flac (path)
        (system "flac -t " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-wv (path)
        (system "wvunpack " (pathquote path) " -o -" " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-ffmpeg (path)
        (deflocal valid tmp tmppath)

        (set valid false)
        (mktmpdir tmp)
        (opt    (set tmppath (+ tmp "/a"))
                (system "ffmpeg -v 24 -i " (pathquote path) " -f null - >/dev/null 2>" tmppath) ; 16=errori 24=errori+warnings
                (= (fsize tmppath) 0)
                (set valid true) )
        (rmhier tmp)
        (truep valid) )

(defnet path-content-is-valid-jpg (path)
        (system "djpeg " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-png (path)
        (system "png2pnm " (pathquote path) " >/dev/null 2>/dev/null") )

(defnet path-content-is-valid-pdf (path)
        (search "Status: Well-Formed and valid"
                (system-stdout->str (homepathp (+ "jhove/jhove -m pdf-hul "
                                                  (pathquote path) )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-is-zip-type-low (path files) net path-is-zip-type-low)
(defnet path-is-zip-type-low (path files @res)
        (deflocal tmp p)
        (mktmpdir tmp)
        (alt    (seq    (pathexists path)
                        (set path (realpath path))
                        (system "cd " (pathquote tmp) " && unzip " (pathquote path) " >/dev/null 2>/dev/null")
                        (for p in files do
                                (pathexists (+ tmp "/" p)) )
                        (set @res true) )
                (set @res false) )
        (rmhier tmp) )

(defun path-is-docx (path)
        (path-is-zip-type-low path
                [ "[Content_Types].xml"
                  "_rels/.rels"
                  "word/document.xml" ] ))

(defun path-is-xps (path)
        (path-is-zip-type-low path
                [ "[Content_Types].xml"
                  "FixedDocSeq.fdseq"
                  "_rels/.rels"
                  "Documents/1" ] ))

(defun path-is-odt (path)
        (path-is-zip-type-low path
                [ "content.xml"
                  "mimetype"
                  "settings.xml"
                  "styles.xml"
                  "META-INF/manifest.xml" ] ))

(defun path-is-epub (path) net path-is-epub)
(defnet path-is-epub (path @res)
        (deflocal tmp p)
        (mktmpdir tmp)
        (alt    (seq    (pathexists path)
                        (set path (realpath path))
                        (system "cd " (pathquote tmp) " && unzip " (pathquote path) " >/dev/null 2>/dev/null")
                        (pathexists (+ tmp "/META-INF/container.xml"))
                        (set p (str-load (+ tmp "/mimetype")))
                        (stringp p)
                        (lmatch p "application/epub+zip")
                        (set @res true) )
                (set @res false) )
        (rmhier tmp) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-extension (path) net path-extension)
(defnet path-extension (path @ext)
        (deflocal i)
        (set @ext "")
        (opt    (search "." path i (maxint))
                (> i 0)
                (<> <path (- i 1)> '/')
                (set @ext (sub (+ i 1) (maxint) path))
                (not (search "/" @ext)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-change-extension (path new-ext) (path-change-extension-basic false path new-ext))
(defun path-change-extension-overwrite (path new-ext) (path-change-extension-basic true path new-ext))
(defun path-change-extension-basic (overwrite path new-ext) net path-change-extension-basic)
(defnet path-change-extension-basic (overwrite path new-ext @path)
        (deflocal ext)
        (set @path path)
        (set ext (path-extension @path))
        (if (and (= new-ext ext) (not overwrite))
        then    (set @path (+ @path "." ext))
        else    (rmatch remove @path ext)
                (set @path (+ @path (if (rmatch @path ".") "" ".") new-ext)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-truncate (path maxlen) net path-truncate)
(defnet path-truncate (path maxlen @path)
        (deflocal e)
        (set @path path)
        (set e (path-extension @path))
        (rmatch remove @path e)
        (opt    (rmatch remove @path ".")
                (set e (+ "." e)) )
        (if (>= (length e) maxlen)
        then    (set @path path)
                (set e "") )
        (set @path (+ (sub 0 (- maxlen (length e)) @path) e)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun unhex-path (path) net unhex-path)
(defnet unhex-path (path @path)
        (deflocal i)

        (alt    (seq    (search "%" path i)
                        (set @path (+ (sub 0 i path)
                                      (int->char (hex->int (sub (+ i 1) 2 path)))
                                      (unhex-path (sub (+ i 3) (maxint) path)) )))
                (set @path path) ))

(defun adjust-path (path)
        (if (cmingw)
                (find-and-replace (unhex-path path) "\\" "/")
                (unhex-path path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet match-case (s1 s2)
        (lmatch case remove s1 s2)
        (= s1 "") )

(defun match-case (s1 s2) net match-case-low)
(defnet match-case-low (s1 s2 @res)
        (alt    (seq    (match-case s1 s2)
                        (set @res true) )
                (set @res false) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun csv-fields (s) net csv-fields)
(defnet csv-fields (s @q)
        (deflocal usetab i)

        (stringp s)
        (set @q (queue))
        (set usetab false)
        (opt*   (alt    (seq    (search "\t" s i)
                                (queue-put @q (sub 0 i s))
                                (set s (sub (+ i 1) (maxint) s))
                                (set usetab true) )
                        (seq    (not usetab)
                                (lmatch remove s "\"")
                                (search "\"" s i)
                                (queue-put @q (sub 0 i s))
                                (set s (sub (+ i 1) (maxint) s))
                                (alt    (= s "")
                                        (lmatch remove s ",") ))
                        (seq    (not usetab)
                                (search "," s i)
                                (queue-put @q (sub 0 i s))
                                (set s (sub (+ i 1) (maxint) s)) )
                        (seq    (queue-put @q s)
                                (fail) ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun isbn-is-valid (s) net isbn-is-valid)
(defnet isbn-is-valid (s @res)
        (set @res true)
        (alt    (isbn13-is-valid s)
                (isbn10-is-valid s)
                (set @res false) ))

(defnet isbn13-is-valid (s)
        (deflocal c p t)

        (= (length s) 13)
        (set p 1)
        (set t 0)
        (for c in s do
                (in c '0' .. '9')
                (inc t (* p (- (length c) (length '0'))))
                (set p (- 4 p)) )
        (= (% t 10) 0) )

(defnet isbn10-is-valid (s)
        (deflocal c p t)

        (= (length s) 10)
        (set p 10)
        (set t 0)
        (for c in (sub 0 9 s) do
                (in c '0' .. '9')
                (inc t (* p (- (length c) (length '0'))))
                (dec p) )
        (set c <s 9>)
        (alt    (seq    (in c '0' .. '9')
                        (inc t (- (length c) (length '0'))) )
                (seq    (= c 'X')
                        (inc t 10) ))
        (= (% t 11) 0) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun int2roman (n) net int2roman)
(defnet int2roman (n @s)
        (set @s (tile (div n 1000) 'M'))
        (set n (% n 1000))
        (if (= n 999)
        then    (inc @s "IM")
                (set n 0) )
        (if (= n 995)
        then    (inc @s "VM")
                (set n 0) )
        (if (>= n 990)
        then    (inc @s "XM")
                (dec n 990) )
        (if (in n 950 .. 959)
        then    (inc @s "LM")
                (dec n 950) )
        (if (>= n 900)
        then    (inc @s "CM")
                (dec n 900) )
        (if (>= n 500)
        then    (inc @s "D")
                (dec n 500) )
        (if (= n 499)
        then    (inc @s "ID")
                (set n 0) )
        (if (= n 495)
        then    (inc @s "VD")
                (set n 0) )
        (if (>= n 490)
        then    (inc @s "XD")
                (dec n 490) )
        (if (in n 450 .. 459)
        then    (inc @s "LD")
                (dec n 450) )
        (if (>= n 400)
        then    (inc @s "CD")
                (dec n 400) )
        (inc @s (tile (div n 100) 'C'))
        (set n (% n 100))
        (if (= n 99)
        then    (inc @s "IC")
                (set n 0) )
        (if (= n 95)
        then    (inc @s "VC")
                (set n 0) )
        (if (>= n 90)
        then    (inc @s "XC")
                (dec n 90) )
        (if (>= n 50)
        then    (inc @s "L")
                (dec n 50) )
        (if (= n 49)
        then    (inc @s "IL")
                (set n 0) )
        (if (= n 45)
        then    (inc @s "VL")
                (set n 0) )
        (if (>= n 40)
        then    (inc @s "XL")
                (dec n 40) )
        (inc @s (tile (div n 10) 'X'))
        (set n (% n 10))
        (if (= n 9)
        then    (inc @s "IX")
                (set n 0) )
        (if (= n 4)
        then    (inc @s "IV")
                (set n 0) )
        (if (>= n 5)
        then    (inc @s "V")
                (dec n 5) )
        (inc @s (tile n 'I')) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun odtpath->txt (path) net odtpath->txt)
(defnet odtpath->txt (path @s)
        (deflocal tmp s)

        (mktmpdir tmp)
        (alt    (odtpath->txt-low tmp path @s)
                (seq    (rmhier tmp)
                        (fail) ))
        (rmhier tmp) )

(defun odtraw->txt (odt) net odtraw->txt)
(defnet odtraw->txt (odt @s)
        (deflocal tmp path)

        (mktmpdir tmp)
        (alt    (seq    (set path (+ tmp "/0.odt"))
                        (raw-save path odt)
                        (odtpath->txt-low tmp path @s) )
                (seq    (rmhier tmp)
                        (fail) ))
        (rmhier tmp) )

(defnet odtpath->txt-low (tmp path @s)
        (deflocal s i)

        (set s (+ tmp "/0.txt"))
        (if (path-is-odt path)
        then    (system "trpodt2txt --encoding=UTF-8 --width=-1 --output="
                        (pathquote s) " " (pathquote path)
                        " >/dev/null 2>/dev/null" )
        else    (truep (path-is-epub path))
                (system "epub2txt -n " (pathquote path) " >" (pathquote s)
                        " 2>/dev/null" ))
        (set s (str-load s))
        (stringp s)
        (set @s "")
        (repeat (str-readline s tmp)
                until (= tmp undef)
                (rtrim tmp)
                ; questi brutti hack servono per ovviare alle lunghissime
                ; linee tratteggiate generate da odt2txt in
                ; corrispondenza dei paragrafi H1, H2...
                (if (rmatch tmp "=")
                then    (set i (rtrim tmp '='))
                        (if (> (- (length tmp) (length i)) 8)
                        then    (set tmp (+ i "========")) )
                else    (if (rmatch tmp "-")
                then    (set i (rtrim tmp '-'))
                        (if (> (- (length tmp) (length i)) 8)
                        then    (set tmp (+ i "--------")) )))
                (alt    (<= (length tmp) 60)
                        (seq    (search " " tmp i)
                                (<= i 60) )
                        (print "odt->txt warning: linea lunga senza spazi" nl
                               tmp nl ))
                (inc @s tmp "\n") )
        (rtrim @s '\n') )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet odtpath->pixlist (path dstpath @cnt)
        (deflocal tmp a)

        (mktmpdir tmp)
        (alt    (seq    (system "cd " tmp " && unzip " (pathquote path)
                                " >/dev/null 2>/dev/null" )
                        (set a (array 2))
                        (set <a 0> dstpath)
                        (set <a 1> @cnt)
                        (filesystem-visit tmp (netptr odtpath->pixlist-cback) a)
                        (set @cnt <a 1>)
                        (rmhier tmp) )
                (seq    (rmhier tmp)
                        (fail) )))

(defnet odtpath->pixlist-cback (path name a)
        (deflocal m ext)

        (set m (magic-file path))
        (opt    (not (rmatch path "/Thumbnails/thumbnail.png"))
                (alt    (seq    (search case "JPEG image data" m)
                                (set ext "jpg") )
                        (seq    (search case "PNG image data" m)
                                (set ext "png") ))
                (filecopy path (+ <a 0> "/" (int->str <a 1> 9 '0') "." ext))
                (inc <a 1>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun less0 (x y) (< <x 0> <y 0>))
(defun less1 (x y) (< <x 1> <y 1>))
(defun less2 (x y) (< <x 2> <y 2>))
(defun less3 (x y) (< <x 3> <y 3>))
(defun less4 (x y) (< <x 4> <y 4>))
(defun less5 (x y) (< <x 5> <y 5>))
(defun less6 (x y) (< <x 6> <y 6>))
(defun less7 (x y) (< <x 7> <y 7>))
(defun less8 (x y) (< <x 8> <y 8>))
(defun less9 (x y) (< <x 9> <y 9>))
(defun lesscar (x y) (< (car x) (car y)))
(defun lesscdr (x y) (< (cdr x) (cdr y)))
(defun greater-1 (x y) (> x y))
(defun greater0 (x y) (> <x 0> <y 0>))
(defun greater1 (x y) (> <x 1> <y 1>))
(defun greater2 (x y) (> <x 2> <y 2>))
(defun greater3 (x y) (> <x 3> <y 3>))
(defun greater4 (x y) (> <x 4> <y 4>))
(defun greater5 (x y) (> <x 5> <y 5>))
(defun greater6 (x y) (> <x 6> <y 6>))
(defun greater7 (x y) (> <x 7> <y 7>))
(defun greater8 (x y) (> <x 8> <y 8>))
(defun greater9 (x y) (> <x 9> <y 9>))
(defun greatercar (x y) (> (car x) (car y)))
(defun greatercdr (x y) (> (cdr x) (cdr y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet box-size-fixed (w-old h-old w-fixed h-fixed @w-new @h-new)
        (deflocal r)

        (set r (min (/ w-fixed w-old) (/ h-fixed h-old)))
        (set @w-new (rint (* r w-old)))
        (set @h-new (rint (* r h-old))) )

(defnet box-size-max (w-old h-old w-max h-max @w-new @h-new)
        (deflocal r)

        (set r (min 1 (/ w-max w-old) (/ h-max h-old)))
        (set @w-new (rint (* r w-old)))
        (set @h-new (rint (* r h-old))) )

(defnet box-size-min (w-old h-old w-min h-min @w-new @h-new)
        (deflocal r)

        (set r (max 1 (min (/ w-min w-old) (/ h-min h-old))))
        (set @w-new (rint (* r w-old)))
        (set @h-new (rint (* r h-old))) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun queue->list (q) net queue->list)
(defnet queue->list (q @l)
        (deflocal i)

        (queuep q)
        (set @l nil)
        (for i in 0 .. (- (length q) 1) rev do
                (list-push @l <q i>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun assoc->array (asc) net assoc->array)
(defnet assoc->array (asc @arr)
        (deflocal i)

        (assocp asc)
        (set @arr (array (length asc)))
        (for i in asc do
                (set <@arr (for-pos)> i) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun assoc-default (default-list) net assoc-default)
(defnet assoc-default (default-list @a)
        (deflocal i)

        (set @a (assoc))
        (for i in default-list do
                (set <@a (car i)> (cdr i)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun assoc-choice (asc) net assoc-choice)
(defnet assoc-choice (asc @elem)
        (for @elem in asc do until true) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun words (s) net words)
(defun words-exclude (s l) net words-exclude)

(defnet words (s @a)
        (words-exclude s nil @a) )

(defnet words-exclude (s l @a)
        (deflocal w)

        (set @a (assoc))
        (for w in l do
                (set <@a w> 1) )
        (words-add @a s)
        (for w in l do
                (assoc-clr @a w) ))

(defnet words-add (a s)
        (deflocal c i)

        (set s (utf8-tolower s))
        (for c in s do
                (if (in c " \n\r\f\t.,;:?!/\\\"'<=>&()[]{}|")
                then    (if (<> i undef)
                        then    (words-put a (sub i (- (for-pos) i) s))
                                (clr i) )
                else    (if (= i undef)
                        then    (set i (for-pos)) )))
        (if (<> i undef)
        then    (words-put a (sub i (maxint) s)) ))

(defnet words-put (a s)
        (if (and (>= (length s) 3)
                 (= (str->num s) undef) )
        then    (inc <a s>) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet list-push (@lst obj)
        (set @lst (cons obj @lst)) )

(defnet list-pop (@lst @obj)
        (set @obj (car @lst))
        (set @lst (cdr @lst)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet print-tab (nskip nlen s)
        (deflocal t u i)

        (repeat (set t (sub 0 nlen s))
                (set u (sub (length t) (maxint) s))
                (opt    (<> u "")
                        (<> <u 0> ' ')
                        (search " " t i (maxint))
                        (set t (sub 0 i s))
                        (set u (sub (+ i 1) (maxint) s)) )
                (print t nl)
                until (= u "")
                (set s (ltrim u))
                (print (tile nskip)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun system-stdout->str (cmdline) net system-stdout->str)
(defnet system-stdout->str (cmdline @str)
        (deflocal tmpdir tmp)

        (clr @str)
        (mktmpdir tmpdir)
        (opt    (set tmp (+ tmpdir "/fifo"))
                (mkfifo tmp)
                (system cmdline " > " tmp " 2>/dev/null &")
                (set @str (str-load tmp)) )
        (rmhier tmpdir) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun ipv4-external-address () net ipv4-external-address)
(defnet ipv4-external-address (@addr)
        (deflocal tmpdir tmppath cmd cnt s l i)

        (clr @addr)
        (mktmpdir tmpdir)
        (opt    (set tmppath (+ tmpdir "/a"))
                ;(set cmd (+ "wget ipinfo.io/ip -O " tmppath))
                (set cmd (+ "wget http://checkip.amazonaws.com -O " tmppath))
                (system cmd " >/dev/null 2>/dev/null &")
                (set cnt 0)
                (repeat (sleep 0.05)
                        (set s (system-stdout->str "ps xa"))
                        (clr i)
                        (repeat (str-readline s l)
                                until (= l undef)
                                (if (search cmd l)
                                then    (ltrim l)
                                        (search " " l i)
                                        (set i (str->num (sub 0 i l))) ))
                        until (not (integerp i))
                        (inc cnt)
                        (if (= cnt 32) ; max 1.6 secondi
                        then    (system "sudo kill -SIGKILL " i " >/dev/null 2>/dev/null")
                                (fail) ))
                (set @addr (str-load tmppath)) )
        (rmhier tmpdir)
        (stringp @addr)
        (trim-trn @addr)
        (set s @addr)
        (search "." s i)
        (integerp (str->num (sub 0 i s)))
        (set s (sub (+ i 1) (maxint) s))
        (search "." s i)
        (integerp (str->num (sub 0 i s)))
        (set s (sub (+ i 1) (maxint) s))
        (search "." s i)
        (integerp (str->num (sub 0 i s)))
        (integerp (str->num (sub (+ i 1) (maxint) s))) )

(defnet ipv4-connected-low (@res @addr)
        (deflocal i)

        (set @res false)
        (opt    (set @addr (ipv4-external-address))
                (stringp @addr)
                (not (lmatch @addr "192.168.1."))
                (not (rmatch @addr ".0.0"))
                (set @res true) ))

(defun ipv4-connected () net ipv4-connected-func)
(defnet ipv4-connected-func (@res)
        (deflocal addr)
        (ipv4-connected-low @res addr) )

(defnet ipv4-connected () (truep (ipv4-connected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun djvu-jpeg-list (djvupath) net  djvu-jpeg-list)
(defnet djvu-jpeg-list (djvupath @l)
        (deflocal tmpdir tmp f l i)

        (mktmpdir tmpdir)
        (set tmp (+ tmpdir "/fifo"))
        (mkfifo tmp)
        (alt    (seq    (system "djvudump " (pathquote djvupath) " > " tmp " 2>/dev/null &")
                        (set f (fopenro tmp))
                        (<> f undef)
                        (set @l (queue))
                        (repeat (set l (freadline f))
                                until (= l undef)
                                (ltrim l ' ' '\t')
                                (rtrim l ' ' '\t')
                                (opt    (lmatch remove l "FORM:DJVU")
                                        (search ".djvu}" l i (maxint))
                                        (set l (sub 0 i l))
                                        (rmatch case l ".jpg" ".jpeg")
                                        (search "{" l i)
                                        (queue-put @l (sub (+ i 1) (maxint) l)) ))
                        (close f)
                        (> (length @l) 0)
                        (rmhier tmpdir) )
                (seq    (rmhier tmpdir)
                        (fail) )))

(defnet djvu-jpeg-extract (djvupath @dest @tmpdir)
        (deflocal l i pg)

        (djvu-jpeg-list djvupath l)
        (mktmpdir @tmpdir)
        (alt    (seq    (set @dest (+ @tmpdir "/" (fullpath->name djvupath)))
                        (opt (rmatch case remove @dest ".djvu"))
                        (mkdir @dest)
                        (set djvupath (pathquote djvupath))
                        (set pg 1)
                        (for i in l do
                                (system "djvuextract -page=" pg " " djvupath " BGjp=" (pathquote (+ @dest "/" i))
                                        " >/dev/null 2>/dev/null" )
                                (inc pg) ))
                (seq    (rmhier @tmpdir)
                        (fail) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

