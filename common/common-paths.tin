;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-separator (path)
        (if (clinux) '/'
        (if (cmingw) (if (search "/" path) '/' '\\')
        '/' )))

(defun realpathifexists (path) net realpathifexists)
(defnet realpathifexists (path @path)
        (set @path (realpath path))
        (if (not (stringp @path))
        then    (set @path path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mkdirhier (path)
        (deflocal s i)

        (set s (path-separator path))
        (rtrim path s)
        (if (not (pathexists path))
        then    (search (sprint s) path i (maxint))
                (mkdirhier (sub 0 (+ i 1) path))
                (mkdir path) ))

(defnet rmhier (path)
        (deflocal s p)

        (set s (path-separator path))
        (rtrim path s)
        (<> path "")
        (if (cmingw)
        then    (not (rmatch path ":")) )
        (if (pathexists path)
        then    (set s (sprint s))
                (if (isdir path)
                then    (for p in (directory path) do
                                (if (and (<> p ".") (<> p ".."))
                                then    (rmhier (+ path s p)) )))
                (remove path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun currpath () net currpath)
(defnet currpath (@path)
        (deflocal i)

        (set @path (cwd))
        (set i (path-separator @path))
        (if (not (rmatch @path i))
        then    (inc @path i) ))

(defun currpathp (p) (+ (currpath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun callpath () net callpath)
(defnet callpath (@path)
        (deflocal i)

        (set @path (argv 0))
        (alt    (seq    (search (sprint (path-separator @path)) @path i (maxint))
                        (set @path (sub 0 i @path)) )
                (set @path (currpath)) )
        (set @path (realpathifexists @path))
        (if (not (pathexists @path))
        then    (set @path (currpath)) )
        (set i (path-separator @path))
        (if (not (rmatch @path i))
        then    (inc @path i) ))

(defun callpathp (p) (+ (callpath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun homepath () net homepath)
(defnet homepath (@path)
        (deflocal i)

        (if (clinux)
        then    (set @path (getenv "HOME"))
        else    (if (cmingw)
                then    (set @path (+ (getenv "HOMEDRIVE") (getenv "HOMEPATH")))
                        (if (not (pathexists @path))
                        then    (set @path (getenv "USERPROFILE")) )
                else    (set @path (getenv "HOME")) ))
        (if (not (pathexists @path))
        then    (set @path (callpath)) )
        (set @path (realpathifexists @path))
        (set i (path-separator @path))
        (if (not (rmatch @path i))
        then    (inc @path i) ))

(defun homepathp (p) (+ (homepath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun datapath () net datapath)
(defnet datapath (@path)
        (deflocal i)

        (set @path (homepathp ".treep"))
        (if (not (pathexists @path))
        then    (mkdir @path) )
        (set i (path-separator @path))
        (if (not (rmatch @path i))
        then    (inc @path i) ))

(defun datapathp (p) (+ (datapath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun tmppath () net tmppath)
(defnet tmppath (@path)
        (deflocal i)

        (if (clinux)
        then    (set @path "/tmp")
        else    (if (cmingw)
                then    (set @path (getenv "TEMP"))
                else    (set @path "/tmp") ))
        (if (not (pathexists @path))
        then    (set @path (callpath)) )
        (set @path (realpathifexists @path))
        (set i (path-separator @path))
        (if (not (rmatch @path i))
        then    (inc @path i) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mktmpdir (@path)
        (deflocal prefix i)

        (set prefix (+ (tmppath) (random-alphanumeric-string 4)))
        (set i 0)
        (repeat (set @path (+ prefix (int->str i 4 '0')))
                (alt    (seq    (not (pathexists @path))
                                (mkdir @path)
                                (set i 0) )
                        (inc i) )
                until (= i 0) )
        (set i (path-separator @path))
        (if (not (rmatch @path i))
        then    (inc @path i) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet filesystem-visit (path cback udata)
        (filesystem-visit-limit path cback udata (maxint)) )

(defnet filesystem-visit-limit (path cback udata max-level)
        (pathexists path)
        (truep (isdir path))
        (filesystem-visit-low path cback udata (path-separator path) 0 max-level) )

(defnet filesystem-visit-low (path cback udata s level max-level)
        (deflocal c e p r d)

        (set c (if (rmatch path s) "" s))
        (set r (array 0))
        (if (< level max-level)
        then    (set d (array 0)) )
        (for e in (directory path) do
                (if (not (in e [ "." ".." ]))
                then    (set p (+ path c e))
                        (if (isreg p)
                        then    (array-append r (cons p e))
                        else    (if (and (isdir p) (< level max-level))
                                then    (array-append d e) ))))
        (sort r (funptr lesscdr))
        (for e in r do
                (call cback (car e) (cdr e) udata) )
        (if (< level max-level)
        then    (sort d)
                (inc level)
                (for e in d do
                        (filesystem-visit-low (+ path c e) cback udata s level max-level) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;; restituisce, se lo trova, un path esistente che matcha a destra      ;;;;
;;;; rpath                                                                ;;;;
;;;; cercandolo in alcune directory `standard`                            ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun search-path-default (rpath) net search-path-default)
(defnet search-path-default (rpath @path)
        (deflocal a path i j p)

        (set a (assoc))
        (for path in (list (currpath)
                           (datapath)
                           (homepathp "wd/programming/treep/trp")
                           (callpath)
                           (currpathp "TreeP")
                           (callpathp "TreeP")
                           (homepathp "TreeP") ) do
                (repeat (alt    (seq    (rtrim path '/')
                                        (search "/" path i (maxint)) )
                                (clr i) )
                        (if (pathexists path)
                        then    (for j in [ "" "common/" "icons/" "sounds/" "common/icons/" "common/sounds/" ] do
                                        (set p (+ path (if (rmatch path "/") "" "/") j rpath))
                                        (if (= <a p> undef)
                                        then    (if (pathexists p)
                                                then    (set @path p)
                                                else    (set <a p> true) ))))
                        until (stringp @path)
                        until (not (integerp i))
                        (set path (sub 0 (+ i 1) path)) )
                until (stringp @path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun search-path-first (path regex)
        (search-path-first-limit path regex (maxint)) )

(defun search-path-first-limit (path regex max-level) net search-path-first-limit)
(defnet search-path-first-limit (path regex max-level @path)
        (deflocal q)

        (set q (search-path-limit-low path regex max-level true))
        (queuep q)
        (set @path (queue-get q)) )

(defun search-path (path regex)
        (search-path-limit-low path regex (maxint) false) )

(defun search-path-limit (path regex max-level)
        (search-path-limit-low path regex max-level false) )

(defun search-path-limit-low (path regex max-level first) net search-path-limit-low)
(defnet search-path-limit-low (path regex max-level first @q)
        (deflocal re)

        (set re (regcomp regex (cmacro REG_ICASE)))
        (<> re undef)
        (set @q (queue))
        (opt (filesystem-visit-limit path (netptr search-path-limit-cback) (list @q re first) max-level))
        (close re) )

(defnet search-path-limit-cback (path name u)
        (opt    (regexec <u 1> name)
                (queue-put <u 0> path) )
        (or (not <u 2>) (= (length <u 0>) 0)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun pathquote (path) net pathquote)
(defnet pathquote (path @qpath)
        (deflocal l c)
        (set l (queue))
        (for c in path do
                (if (not (or (in c 'a' .. 'z')
                             (in c 'A' .. 'Z')
                             (in c '0' .. '9')
                             (in c [ '.' '+' '-' '_' '=' '/' ] ) ))
                then    (queue-put l '\\') )
                (queue-put l c) )
        (set @qpath (implode l)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-legalize (path) net path-legalize)
(defnet path-legalize (path @qpath)
        (deflocal l c)
        (set l (queue))
        (for c in path do
                (if (in c [ '!' '?' '*' '\\' '/' ])
                then    (set c '-') )
                (queue-put l c) )
        (set @qpath (implode l)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun fullpath->name (path) net fullpath->name)
(defnet fullpath->name (path @name)
        (deflocal i)

        (stringp path)
        (alt    (seq    (search (sprint (path-separator path)) path i (maxint))
                        (set @name (sub (+ i 1) (maxint) path)) )
                (set @name path) ))

(defun fullpath->dir (path) net fullpath->dir)
(defnet fullpath->dir (path @path)
        (deflocal i)

        (stringp path)
        (set i (path-separator @path))
        (rmatch remove path (fullpath->name path))
        (if (and (<> path "") (not (rmatch path i)))
        then    (inc path i) )
        (set @path path) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-suggest-extension (path) net path-suggest-extension)
(defnet path-suggest-extension (path @ext)
        (deflocal m)
        (set m (magic-file path))
        (stringp m)
        (alt    (seq    (= "TreeP source code text" m)
                        (alt    (path-suggest-extension-permissive path [ "tin" ] @ext)
                                (set @ext "trp") ))
                (seq    (search case "Perl script" m)
                        (set @ext "pl") )
                (seq    (search case "Web Open Font Format (Version 2)" m)
                        (set @ext "woff2") )
                (seq    (search case "Web Open Font Format" m)
                        (set @ext "woff") )
                (seq    (search case "Spline Font Database" m)
                        (set @ext "sfd") )
                (seq    (search case "Embedded OpenType (EOT)" m)
                        (set @ext "eot") )
                (seq    (search case "TrueType Font data" m)
                        (set @ext "ttf") )
                (seq    (search case "Netpbm image data" m)
                        (alt    (seq    (search case "pixmap" m)
                                        (set @ext "ppm") )
                                (seq    (search case "greymap" m)
                                        (set @ext "pgm") )
                                (seq    (search case "bitmap" m)
                                        (set @ext "pbm") )))
                (seq    (search case "JPEG image data" m)
                        (set @ext "jpg") )
                (seq    (search case "DICOM medical imaging data" m)
                        (set @ext "dic") )
                (seq    (search case "JPEG 2000" m)
                        (set @ext "jp2") )
                (seq    (search case "Web/P image" m)
                        (set @ext "webp") )
                (seq    (search case "X pixmap image" m)
                        (search case "ASCII text" m)
                        (set @ext "xpm") )
                (seq    (search case "PNG image" m)
                        (set @ext "png") )
                (seq    (search case "GIF image data" m)
                        (set @ext "gif") )
                (seq    (search case "TIFF image data" m)
                        (set @ext "tif") )
                (seq    (search case "PC bitmap" m)
                        (search case "Windows " m)
                        (set @ext "bmp") )
                (seq    (search case "windows icon resource" m)
                        (set @ext "ico") )
                (seq    (search case "SVG Scalable Vector Graphics image" m)
                        (set @ext "svg") )
                (seq    (search case "MPEG transport stream data" m)
                        (set @ext "ts") )
                (seq    (search case "MPEG sequence" m)
                        (alt    (seq    (search case "program multiplex" m)
                                        (search case ", v2," m)
                                        (path-suggest-extension-permissive path [ "VOB" "sub" ] @ext) )
                                (seq    (search case "Y'CbCr 4:2:0 video" m)
                                        (alt    (seq    (search case ", v1," m)
                                                        (set @ext "m1v") )
                                                (seq    (search case ", v2," m)
                                                        (set @ext "m2v") )))
                                (set @ext "mpg") ))
                (seq    (search case "Windows Television DVR Media" m)
                        (set @ext "wtv") )
                (seq    (search case "Apple QuickTime movie" m)
                        (set @ext "mov") )
                (seq    (search case "ISO Media" m)
                        (alt    (path-suggest-extension-permissive path [ "mov" "3gp" "m4a" ] @ext)
                                (set @ext "mp4") ))
                (seq    (search case "RIFF (little-endian) data" m)
                        (alt    (seq    (search "WAVE audio" m)
                                        (set @ext "wav") )
                                (seq    (search "AVI" m)
                                        (set @ext "avi") )
                                (seq    (search "wrapped MPEG" m)
                                        (set @ext "mpg") )))
                (seq    (search case "Microsoft ASF" m)
                        (alt    (path-suggest-extension-permissive path [ "wma" ] @ext)
                                (set @ext "wmv") ))
                (seq    (search case "RealMedia file" m)
                        (alt    (path-suggest-extension-permissive path [ "ra" ] @ext)
                                (set @ext "rm") ))
                (seq    (search case "Matroska data" m)
                        (alt    (path-suggest-extension-permissive path [ "mka" "webm" ] @ext)
                                (set @ext "mkv") ))
                (seq    (search case "WebM" m)
                        (set @ext "webm") )
                (seq    (search case "Ogg data" m)
                        (alt    (seq    (or (search case "Theora video" m)
                                            (search case "Skeleton" m) )
                                        (set @ext "ogv") )
                                (seq    (search case "ogm video" m)
                                        (set @ext "ogm") )
                                (seq    (search case "audio" m)
                                        (alt    (path-suggest-extension-permissive path [ "spx" ] @ext)
                                                (set @ext "ogg") ))))
                (seq    (search case "Macromedia Flash Video" m)
                        (set @ext "flv") )
                (seq    (search case "Macromedia Flash Data" m)
                        (set @ext "swf") )
                (seq    (search case "MPEG ADTS" m)
                        (alt    (seq    (search case "AAC" m)
                                        (set @ext "aac") )
                                (seq    (search case " layer III" m)
                                        (set @ext "mp3") )
                                (seq    (search case " layer II" m)
                                        (set @ext "mp2") )))
                (seq    (search case "Audio file with ID3" m)
                        (path-suggest-extension-permissive path [ "mp3" ] @ext) )
                (seq    (search case "ATSC A/52" m)
                        (set @ext "ac3") )
                (seq    (search case "FLAC audio bitstream data" m)
                        (set @ext "flac") )
                (seq    (search case "Monkey's Audio compressed format" m)
                        (set @ext "ape") )
                (seq    (search case "WavPack Lossless Audio" m)
                        (set @ext "wv") )
                (seq    (search case "Java archive data" m)
                        (set @ext "jar") )
                (seq    (alt    (lmatch case m "tar archive")
                                (search case " tar archive" m)
                                (search case "\ntar archive" m) )
                        (set @ext "tar") )
                (seq    (search case "RAR archive data" m)
                        (alt    (seq    (path-suggest-extension-permissive path [ "cbr" "cbz" ] @ext)
                                        (if (= @ext "cbz")
                                        then    (set @ext "cbr") ))
                                (set @ext "rar") ))
                (seq    (search case "7-zip archive data" m)
                        (set @ext "7z") )
                (seq    (alt    (search case "Zip archive data" m)
                                (search case "Zip data" m) )
                        (alt    (seq    (path-suggest-extension-permissive path [ "cbr" "cbz" "jar" "epub" "docx" "odt" "ods" "xps" "htmlz" "xlsx" "apk" ] @ext)
                                        (if (= @ext "cbr")
                                        then    (set @ext "cbz") ))
                                (set @ext "zip") ))
                (seq    (search case "gzip compressed data" m)
                        (alt    (path-suggest-extension-permissive path [ "tgz" ] @ext)
                                (set @ext "gz") ))
                (seq    (search case "brotli compressed data" m)
                        (set @ext "br") )
                (seq    (search case "bzip2 compressed data" m)
                        (set @ext "bz2") )
                (seq    (search case "XZ compressed data" m)
                        (set @ext "xz") )
                (seq    (search case "zstandard compressed data" m)
                        (set @ext "zst") )
                (seq    (search case "lzip compressed data" m)
                        (set @ext "lz") )
                (seq    (search case "compress'd data 16 bits" m)
                        (set @ext "Z") )
                (seq    (search case "Debian binary package" m)
                        (set @ext "deb") )
                (seq    (search case "RPM " m)
                        (search case " bin " m)
                        (set @ext "rpm") )
                (seq    (search case "cpio archive" m)
                        (set @ext "cpio") )
                (seq    (search case "current ar archive" m)
                        (path-suggest-extension-permissive path [ "a" "lib" ] @ext) )
                (seq    (search case "BitTorrent file" m)
                        (set @ext "torrent") )
                (seq    (search case "Microsoft Reader eBook Data" m)
                        (set @ext "lit") )
                (seq    (search case "EPUB document" m)
                        (set @ext "epub") )
                (seq    (search case "Mobipocket E-book" m)
                        (alt    (path-suggest-extension-permissive path [ "azw" "azw3" "azw4" "mobi" "prc" ] @ext)
                                (set @ext "mobi") ))
                (seq    (search case "PostScript document text" m)
                        (set @ext "ps") )
                (seq    (search case "PDF document" m)
                        (set @ext "pdf") )
                (seq    (search "DjVu" m)
                        (or     (search case "multiple page document" m)
                                (search case "single page document" m) )
                        (set @ext "djvu") )
                (seq    (search case "MS Windows HtmlHelp Data" m)
                        (set @ext "chm") )
                (seq    (search case "TeX DVI file" m)
                        (set @ext "dvi") )
                (seq    (search case "OpenDocument Text" m)
                        (set @ext "odt") )
                (seq    (search case "OpenDocument Spreadsheet" m)
                        (set @ext "ods") )
                (seq    (search case "Rich Text Format data" m)
                        (set @ext "rtf") )
                (seq    (search case "CDFV2 Microsoft Word" m)
                        (set @ext "doc") )
                (seq    (alt    (search case "CDF V2 Document" m)
                                (search case "Document File V2 Document" m) )
                        (path-suggest-extension-permissive path [ "doc" "ppt" ] @ext) )
                (seq    (alt    (search case "CDFV2 Microsoft Excel" m)
                                (search case "Composite Document File V2 Document" m) )
                        (path-suggest-extension-permissive path [ "xls" ] @ext) )
                (seq    (search case "HTML" m)
                        (search case "document" m)
                        (search case "text" m)
                        (path-suggest-extension-permissive path [ "htm" "html" "xls" ] @ext)
                        (if (= @ext "htm")
                        then    (set @ext "html") ))
                (seq    (search case "XML" m)
                        (search case "document" m)
                        (search case "text" m)
                        (alt    (path-suggest-extension-permissive path [ "svg" "opf" ] @ext)
                                (set @ext "xml") ))
                (seq    (search case "lyx " m)
                        (search case "text" m)
                        (set @ext "lyx") )
                (seq    (search case "SQLite" m)
                        (alt    (path-suggest-extension-permissive path [ "cfg" ] @ext)
                                (set @ext "db") ))
                (seq    (search case "ext2 filesystem data" m)
                        (set @ext "ext2") )
                (seq    (search case "ISO 9660 CD-ROM filesystem data" m)
                        (set @ext "iso") )
                (seq    (search case "UDF filesystem data" m)
                        (set @ext "iso") )
                (seq    (search case "PE32 executable" m)
                        (search case "MS Windows" m)
                        (alt    (seq    (search case "(dll)" m)
                                        (set @ext "dll") )
                                (set @ext "exe") ))
                (seq    (search case " text" m)
                        (alt    (seq    (= (path-extension path) "")
                                        (set @ext "") )
                                (path-suggest-extension-permissive path
                                        [ "txt" "cue" "log" "srt" "bat" "avs" "mfl" "pgn" "fen" "c" "h" "cpp" "cc" "pas" "hs" "go" "clp" "l" "ss" "sh" ] @ext )))))

(defnet path-suggest-extension-permissive (path ext-l @ext)
        (deflocal found)
        (set found false)
        (for @ext in ext-l do
                (set found (rmatch case path (+ "." @ext)))
                until found )
        (truep found) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

