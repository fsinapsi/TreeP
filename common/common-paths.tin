;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; per semplificare gli algoritmi, un path ha sempre '/' come separatore
; ed è garantito che è sempre singolo e che non contiene "/./" e "/../"

(defun path-fix (path) net path-fix)
(defnet path-fix (path @path)
        (deflocal s t)

        (stringp path)
        (find-and-replace path "\\" "/")
        (set s "")
        (opt*   (search-and-cut "//" path t)
                (inc s t "/")
                (ltrim path '/') )
        (inc s path)
        (find-and-replace s "/./" "/")
        (set @path "")
        (opt*   (search-and-cut "/../" s t)
                (inc @path t)
                (search "/" @path t (maxint))
                (set @path (sub 0 (+ t 1) @path)) )
        (inc @path s) )

; path-fix-dir è come path-fix ma garantisce che il path termini con '/'

(defun path-fix-dir (path) net path-fix-dir)
(defnet path-fix-dir (path @path)
        (path-fix path @path)
        (if (not (rmatch @path "/"))
        then    (inc @path "/") ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-parent (path) net path-parent)
(defnet path-parent (path @path)
        (deflocal drive i)

        (path-fix path path)
        (rtrim path '/')
        (alt    (seq    (= <path 1> ':')
                        (or (in <path 0> 'a' .. 'z') (in <path 0> 'A' .. 'Z'))
                        (set drive (sub 0 2 path))
                        (set path (sub 2 (maxint) path)) )
                (set drive "") )
        (search "/" path i (maxint))
        (set @path (+ drive (sub 0 i path) "/")) )

(defun path-ancestors (path) net path-ancestors)
(defnet path-ancestors (path @l)
        (set @l nil)
        (opt*   (path-parent path path)
                (list-push @l path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun realpathifexists (path) net realpathifexists)
(defnet realpathifexists (path @path)
        (set @path path)
        (opt    (set @path (realpath @path))
                (path-fix @path @path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mkdirhier (path)
        (deflocal i)

        (path-fix path path)
        (if (not (pathexists path))
        then    (for i in (path-ancestors path) do
                        (if (not (pathexists i))
                        then    (mkdir i) ))
                (mkdir path) ))

(defnet rmhier (path)
        (deflocal p)

        (path-fix path path)
        (rtrim path '/')
        (<> path "")
        (if (cmingw)
        then    (not (rmatch path ":")) )
        (if (pathexists path)
        then    (if (isdir path)
                then    (for p in (directory path) do
                                (if (and (<> p ".") (<> p ".."))
                                then    (rmhier (+ path "/" p)) )))
                (remove path) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet path-is-empty-dir (path)
        (truep (path-is-empty-dir path)) )

(defun path-is-empty-dir (path) net path-is-empty-dir-low)
(defnet path-is-empty-dir-low (path @res)
        (deflocal p)

        (alt    (seq    (pathexists path)
                        (truep (isdir path))
                        (for p in (directory path) do
                                (in p [ "." ".." ]) )
                        (set @res true) )
                (set @res false) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun currpath ()
        (path-fix-dir (cwd)) )

(defun currpathp (p) (+ (currpath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun callpath () net callpath)
(defnet callpath (@path)
        (deflocal i)

        (set @path (argv 0))
        (alt    (seq    (path-fix @path @path)
                        (search "/" @path i (maxint))
                        (set @path (realpathifexists (sub 0 i @path)))
                        (pathexists @path)
                        (path-fix-dir @path @path) )
                (set @path (currpath)) ))

(defun callpathp (p) (+ (callpath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun homepath () net homepath)
(defnet homepath (@path)
        (if (clinux)
        then    (set @path (getenv "HOME"))
        else    (if (cmingw)
                then    (set @path (+ (getenv "HOMEDRIVE") (getenv "HOMEPATH")))
                        (if (not (pathexists @path))
                        then    (set @path (getenv "USERPROFILE")) )
                else    (set @path (getenv "HOME")) ))
        (if (not (pathexists @path))
        then    (set @path (callpath)) )
        (set @path (realpathifexists @path))
        (path-fix-dir @path @path) )

(defun homepathp (p) (+ (homepath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun datapath () net datapath)
(defnet datapath (@path)
        (set @path (homepathp ".treep"))
        (if (not (pathexists @path))
        then    (mkdir @path) )
        (path-fix-dir @path @path) )

(defun datapathp (p) (+ (datapath) p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun tmppath () net tmppath)
(defnet tmppath (@path)
        (if (clinux)
        then    (set @path "/tmp")
        else    (if (cmingw)
                then    (set @path (getenv "TEMP"))
                else    (set @path "/tmp") ))
        (if (not (pathexists @path))
        then    (set @path (callpath)) )
        (set @path (realpathifexists @path))
        (path-fix-dir @path @path) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet mktmpdir (@path)
        (mktmpdir-low @path (tmppath)) )

(defnet mktmpdir-data (@path)
        (deflocal dir)

        (set dir (datapathp "tmp/"))
        (mkdirhier dir)
        (mktmpdir-low @path dir) )

(defnet mktmpdir-low (@path dir)
        (deflocal prefix i)

        (path-fix dir dir)
        (rtrim dir '/')
        (set prefix (+ dir "/" (random-alphanumeric-string 4)))
        (set i 0)
        (repeat (set @path (+ prefix (int->str i 4 '0')))
                (alt    (seq    (not (pathexists @path))
                                (mkdir @path)
                                (set i 0) )
                        (inc i) )
                until (= i 0) )
        (path-fix-dir @path @path) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun directory-ext-is-unknown (l) (= <l 1> 0))
(defun directory-ext-is-fifo (l) (= <l 1> 1))
(defun directory-ext-is-chr (l) (= <l 1> 2))
(defun directory-ext-is-dir (l) (= <l 1> 4))
(defun directory-ext-is-blk (l) (= <l 1> 6))
(defun directory-ext-is-reg (l) (= <l 1> 8))
(defun directory-ext-is-lnk (l) (= <l 1> 10))
(defun directory-ext-is-sock (l) (= <l 1> 12))
(defun directory-ext-is-wht (l) (= <l 1> 14))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defnet filesystem-visit (path cback udata)
        (filesystem-visit-limit path cback udata (maxint)) )

(defnet filesystem-visit-limit (path cback udata max-level)
        (truep (isdir path))
        (filesystem-visit-low path cback udata 0 max-level) )

(defnet filesystem-visit-low (path cback udata level max-level)
        (path-fix path path)
        (filesystem-visit-low-low path cback udata level max-level) )

(defnet filesystem-visit-low-low (path cback udata level max-level)
        (deflocal c i e p r d reg dir)

        (set c (if (rmatch path '/') "" "/"))
        (set r (array 0))
        (if (< level max-level)
        then    (set d (array 0)) )
        (for i in (directory-ext path) do
                (set e <i 2>)
                (if (not (in e [ "." ".." ]))
                then    (set p (+ path c e))
                        (if (directory-ext-is-unknown i)
                        then    (set dir (lstat-mode p))
                                (set reg (isreg dir))
                                (set dir (isdir dir))
                        else    (set reg (directory-ext-is-reg i))
                                (set dir (directory-ext-is-dir i)) )
                        (if reg
                        then    (array-append r (cons p e))
                        else    (if (and dir (< level max-level))
                                then    (array-append d e) ))))
        (sort r (funptr lesscdr))
        (for e in r do
                (call cback (car e) (cdr e) udata) )
        (if (< level max-level)
        then    (sort d)
                (inc level)
                (for e in d do
                        (filesystem-visit-low-low (+ path c e) cback udata level max-level) )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun tree-directory (path) net tree-directory)
(defnet tree-directory (path @tree)
        (deflocal name)

        (path-fix path path)
        (truep (isdir path))
        (alt    (seq    (set path (realpath path))
                        (stringp path)
                        (set name (fullpath->name path)) )
                (set name path) )
        (tree-directory-rec path name @tree) )

(defnet tree-directory-rec (path name @tree)
        (deflocal c i e p dir sub)

        (set c (if (rmatch path '/') "" "/"))
        (set @tree (tree name))
        (for i in (directory-ext path) do
                (set e <i 2>)
                (if (not (in e [ "." ".." ]))
                then    (set p (+ path c e))
                        (if (directory-ext-is-unknown i)
                        then    (set dir (isdir p))
                        else    (set dir (directory-ext-is-dir i)) )
                        (if dir
                        then    (tree-directory-rec p e sub)
                                (tree-append @tree sub)
                        else    (tree-append @tree (tree e)) ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;; restituisce, se lo trova, un path esistente che matcha a destra      ;;;;
;;;; rpath                                                                ;;;;
;;;; cercandolo in alcune directory `standard`                            ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun search-path-default (rpath) net search-path-default)
(defnet search-path-default (rpath @path)
        (deflocal q a p pp i)

        (path-fix rpath rpath)
        (ltrim rpath '/')
        (set q (queue))
        (set a (assoc))
        (for i in (list (currpath)
                        (callpath)
                        (homepathp (+ "wd/programming"))
                        (datapath) ) do
                (queue-put q i) )
        (clr @path)
        (while (> (length q) 0) do
                (set p (queue-get q))
                (opt    (rtrim p '/')
                        (= <a p> undef)
                        (set <a p> true)
                        (inc p '/')
                        (pathexists p)
                        (truep (isdir p))
                        (set pp (+ p rpath))
                        (if (pathexists pp)
                        then    (set @path pp)
                        else    (for i in [ "TreeP"
                                            "treep"
                                            "trp"
                                            "common"
                                            "icons"
                                            "images"
                                            "sounds" ] do
                                        (queue-put q (+ p i)) )
                                (for i in (path-ancestors p) do
                                        (queue-put q i) )))
                until (stringp @path) )
        (stringp @path) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun search-path-first (path regex)
        (search-path-first-limit path regex (maxint)) )

(defun search-path-first-limit (path regex max-level) net search-path-first-limit)
(defnet search-path-first-limit (path regex max-level @path)
        (deflocal q)

        (set q (search-path-limit-low path regex max-level true))
        (queuep q)
        (set @path (queue-get q)) )

(defun search-path (path regex)
        (search-path-limit-low path regex (maxint) false) )

(defun search-path-limit (path regex max-level)
        (search-path-limit-low path regex max-level false) )

(defun search-path-limit-low (path regex max-level first) net search-path-limit-low)
(defnet search-path-limit-low (path regex max-level first @q)
        (deflocal re)

        (set re (regcomp regex (cmacro REG_ICASE)))
        (<> re undef)
        (set @q (queue))
        (opt (filesystem-visit-limit path (netptr search-path-limit-cback) (list @q re first) max-level))
        (close re) )

(defnet search-path-limit-cback (path name u)
        (opt    (regexec <u 1> name)
                (queue-put <u 0> path) )
        (or (not <u 2>) (= (length <u 0>) 0)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun pathquote (path) net pathquote)
(defnet pathquote (path @qpath)
        (deflocal l c)
        (set l (queue))
        (for c in path do
                (if (not (or (in c 'a' .. 'z')
                             (in c 'A' .. 'Z')
                             (in c '0' .. '9')
                             (in c [ '.' '+' '-' '_' '=' '/' ] ) ))
                then    (queue-put l '\\') )
                (queue-put l c) )
        (set @qpath (implode l)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-legalize (path) net path-legalize)
(defnet path-legalize (path @qpath)
        (deflocal l c)
        (set l (queue))
        (for c in path do
                (if (in c [ '!' '?' '*' '\\' '/' ])
                then    (set c '-') )
                (queue-put l c) )
        (set @qpath (implode l)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun fullpath->name (path) net fullpath->name)
(defnet fullpath->name (path @name)
        (deflocal i)

        (path-fix path path)
        (alt    (seq    (search "/" path i (maxint))
                        (set @name (sub (+ i 1) (maxint) path)) )
                (set @name path) ))

(defun fullpath->dir (path) net fullpath->dir)
(defnet fullpath->dir (path @path)
        (path-fix path path)
        (rmatch remove path (fullpath->name path))
        (if (and (<> path "") (not (rmatch path "/")))
        then    (inc path "/") )
        (set @path path) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun path-suggest-extension (path) net path-suggest-extension)
(defnet path-suggest-extension (path @ext)
        (deflocal m)
        (set m (magic-file path))
        (stringp m)
        (alt    (seq    (= "TreeP source code text" m)
                        (alt    (path-suggest-extension-permissive path [ "tin" ] @ext)
                                (set @ext "trp") ))
                (seq    (= "TreeP image data" m)
                        (set @ext "ptg") )
                (seq    (= "JBIG2 image data" m)
                        (set @ext "jbig2") )
                (seq    (= "JB2E image data" m)
                        (set @ext "jb2e") )
                (seq    (search case "Perl script" m)
                        (set @ext "pl") )
                (seq    (search case "Web Open Font Format (Version 2)" m)
                        (set @ext "woff2") )
                (seq    (search case "Web Open Font Format" m)
                        (set @ext "woff") )
                (seq    (search case "Spline Font Database" m)
                        (set @ext "sfd") )
                (seq    (search case "Embedded OpenType (EOT)" m)
                        (set @ext "eot") )
                (seq    (search case "TrueType Font data" m)
                        (set @ext "ttf") )
                (seq    (search case "OpenType font data" m)
                        (set @ext "otf") )
                (seq    (search case "PostScript type" m)
                        (search case "font" m)
                        (alt    (seq    (search case " text" m)
                                        (set @ext "pfa") )
                                (seq    (search case "program data" m)
                                        (set @ext "pfb") )))
                (seq    (search case "ASCII font metrics" m)
                        (set @ext "afm") )
                (seq    (search case "Printer Font Metrics" m)
                        (set @ext "pfm") )
                (seq    (search case "windows icon resource" m)
                        (set @ext "ico") )
                (seq    (search case "Netpbm" m)
                        (search case "image" m)
                        (alt    (seq    (search case " PAM" m)
                                        (set @ext "pam") )
                                (seq    (search case "pixmap" m)
                                        (set @ext "ppm") )
                                (seq    (search case "greymap" m)
                                        (set @ext "pgm") )
                                (seq    (search case "bitmap" m)
                                        (set @ext "pbm") )))
                (seq    (search case "JPEG image data" m)
                        (set @ext "jpg") )
                (seq    (search case "DICOM medical imaging data" m)
                        (set @ext "dic") )
                (seq    (search case "JPEG 2000" m)
                        (set @ext "jp2") )
                (seq    (search case "Web/P image" m)
                        (set @ext "webp") )
                (seq    (search case "QOI image" m)
                        (set @ext "qoi") )
                (seq    (search case "X pixmap image" m)
                        (search case "text" m)
                        (set @ext "xpm") )
                (seq    (search case "PNG image" m)
                        (set @ext "png") )
                (seq    (search case "GIF image data" m)
                        (set @ext "gif") )
                (seq    (search case "Targa image data" m)
                        (set @ext "tga") )
                (seq    (search case "TIFF image data" m)
                        (alt    (path-suggest-extension-permissive path [ "tif" ] @ext)
                                (set @ext "tiff") ))
                (seq    (search case "PC bitmap" m)
                        (search case "Windows " m)
                        (set @ext "bmp") )
                (seq    (or (search case "SVG Scalable Vector Graphics image" m)
                            (search case "SVG XML document" m) )
                        (set @ext "svg") )
                (seq    (search case "MPEG transport stream data" m)
                        (set @ext "ts") )
                (seq    (search case "MPEG sequence" m)
                        (alt    (seq    (search case "program multiplex" m)
                                        (search case ", v2," m)
                                        (path-suggest-extension-permissive path [ "VOB" "sub" ] @ext) )
                                (seq    (search case "Y'CbCr 4:2:0 video" m)
                                        (alt    (seq    (search case ", v1," m)
                                                        (set @ext "m1v") )
                                                (seq    (search case ", v2," m)
                                                        (set @ext "m2v") )))
                                (set @ext "mpg") ))
                (seq    (search case "Windows Television DVR Media" m)
                        (set @ext "wtv") )
                (seq    (search case "Apple QuickTime movie" m)
                        (set @ext "mov") )
                (seq    (search case "ISO Media" m)
                        (alt    (seq    (search case "AVIF Image" m)
                                        (set @ext "avif") )
                                (seq    (search case "HEIF Image" m)
                                        (set @ext "heic") )
                                (path-suggest-extension-permissive path [ "mov" "3gp" "m4a" ] @ext)
                                (set @ext "mp4") ))
                (seq    (search case "RIFF (little-endian) data" m)
                        (alt    (seq    (search "WAVE audio" m)
                                        (set @ext "wav") )
                                (seq    (search "AVI" m)
                                        (set @ext "avi") )
                                (seq    (search "wrapped MPEG" m)
                                        (set @ext "mpg") )))
                (seq    (search case "Microsoft ASF" m)
                        (alt    (path-suggest-extension-permissive path [ "wma" ] @ext)
                                (set @ext "wmv") ))
                (seq    (search case "RealMedia file" m)
                        (alt    (path-suggest-extension-permissive path [ "ra" ] @ext)
                                (set @ext "rm") ))
                (seq    (search case "Matroska data" m)
                        (alt    (path-suggest-extension-permissive path [ "mka" "webm" ] @ext)
                                (set @ext "mkv") ))
                (seq    (search case "WebM" m)
                        (set @ext "webm") )
                (seq    (search case "Ogg data" m)
                        (alt    (seq    (or (search case "Theora video" m)
                                            (search case "Skeleton" m) )
                                        (set @ext "ogv") )
                                (seq    (search case "ogm video" m)
                                        (set @ext "ogm") )
                                (seq    (search case "audio" m)
                                        (alt    (path-suggest-extension-permissive path [ "spx" ] @ext)
                                                (set @ext "ogg") ))))
                (seq    (search case "Macromedia Flash Video" m)
                        (set @ext "flv") )
                (seq    (search case "Macromedia Flash Data" m)
                        (set @ext "swf") )
                (seq    (search case "MPEG ADTS" m)
                        (alt    (seq    (search case "AAC" m)
                                        (set @ext "aac") )
                                (seq    (search case " layer III" m)
                                        (set @ext "mp3") )
                                (seq    (search case " layer II" m)
                                        (set @ext "mp2") )))
                (seq    (search case "Audio file with ID3" m)
                        (path-suggest-extension-permissive path [ "mp3" ] @ext) )
                (seq    (search case "ATSC A/52" m)
                        (set @ext "ac3") )
                (seq    (search case "FLAC audio bitstream data" m)
                        (set @ext "flac") )
                (seq    (search case "Monkey's Audio compressed format" m)
                        (set @ext "ape") )
                (seq    (search case "WavPack Lossless Audio" m)
                        (set @ext "wv") )
                (seq    (search case "Java archive data" m)
                        (set @ext "jar") )
                (seq    (search case "Android package" m)
                        (set @ext "apk") )
                (seq    (alt    (lmatch case m "tar archive")
                                (search case " tar archive" m)
                                (search case "\ntar archive" m) )
                        (set @ext "tar") )
                (seq    (search case "RAR archive data" m)
                        (alt    (seq    (path-suggest-extension-permissive path [ "cbr" "cbz" ] @ext)
                                        (if (= @ext "cbz")
                                        then    (set @ext "cbr") ))
                                (set @ext "rar") ))
                (seq    (search case "7-zip archive data" m)
                        (set @ext "7z") )
                (seq    (alt    (search case "Zip archive data" m)
                                (search case "Zip multi-volume archive data" m)
                                (search case "Zip data" m) )
                        (alt    (seq    (path-suggest-extension-permissive path [ "cbr" "cbz" "jar" "epub"
                                                                                  "docx" "odt" "ods" "xps"
                                                                                  "htmlz" "xlsx" "apk" ] @ext )
                                        (if (= @ext "cbr")
                                        then    (set @ext "cbz") ))
                                (set @ext "zip") ))
                (seq    (search case "gzip compressed data" m)
                        (alt    (path-suggest-extension-permissive path [ "tgz" "xoj" "xopp" ] @ext)
                                (set @ext "gz") ))
                (seq    (search case "xar archive compressed" m)
                        (alt    ;(path-suggest-extension-permissive path [ "pkg" ] @ext)
                                (set @ext "xar") ))
                (seq    (search case "brotli compressed data" m)
                        (set @ext "br") )
                (seq    (search case "bzip2 compressed data" m)
                        (set @ext "bz2") )
                (seq    (search case "XZ compressed data" m)
                        (set @ext "xz") )
                (seq    (search case "zstandard compressed data" m)
                        (set @ext "zst") )
                (seq    (search case "lzip compressed data" m)
                        (set @ext "lz") )
                (seq    (search case "compress'd data 16 bits" m)
                        (set @ext "Z") )
                (seq    (search case "Debian binary package" m)
                        (set @ext "deb") )
                (seq    (search case "RPM " m)
                        (search case " bin " m)
                        (set @ext "rpm") )
                (seq    (search case "cpio archive" m)
                        (set @ext "cpio") )
                (seq    (search case "current ar archive" m)
                        (path-suggest-extension-permissive path [ "a" "lib" ] @ext) )
                (seq    (search case "BitTorrent file" m)
                        (set @ext "torrent") )
                (seq    (search case "Microsoft Reader eBook Data" m)
                        (set @ext "lit") )
                (seq    (search case "EPUB document" m)
                        (set @ext "epub") )
                (seq    (search case "Mobipocket E-book" m)
                        (alt    (path-suggest-extension-permissive path [ "azw" "azw3" "azw4" "mobi" "prc" ] @ext)
                                (set @ext "mobi") ))
                (seq    (search case "csv text" m)
                        (set @ext "csv") )
                (seq    (search case "PostScript document text" m)
                        (set @ext "ps") )
                (seq    (search case "PDF document" m)
                        (set @ext "pdf") )
                (seq    (search "DjVu" m)
                        (or     (search case "multiple page document" m)
                                (search case "single page document" m) )
                        (set @ext "djvu") )
                (seq    (search case "MS Windows HtmlHelp Data" m)
                        (set @ext "chm") )
                (seq    (search case "LaTeX" m)
                        (search case "document" m)
                        (search case "text" m)
                        (set @ext "latex") )
                (seq    (search case "TeX DVI file" m)
                        (set @ext "dvi") )
                (seq    (search case "OpenDocument Text" m)
                        (set @ext "odt") )
                (seq    (search case "OpenDocument Spreadsheet" m)
                        (set @ext "ods") )
                (seq    (search case "Rich Text Format data" m)
                        (set @ext "rtf") )
                (seq    (search case "CDFV2 Microsoft Word" m)
                        (set @ext "doc") )
                (seq    (alt    (search case "CDF V2 Document" m)
                                (search case "Document File V2 Document" m) )
                        (path-suggest-extension-permissive path [ "doc" "ppt" ] @ext) )
                (seq    (alt    (search case "CDFV2 Microsoft Excel" m)
                                (search case "Composite Document File V2 Document" m) )
                        (path-suggest-extension-permissive path [ "xls" ] @ext) )
                (seq    (search case "Microsoft Excel 2007+" m)
                        (path-suggest-extension-permissive path [ "xlsx" ] @ext) )
                (seq    (search case "HTML" m)
                        (search case "document" m)
                        (search case "text" m)
                        (path-suggest-extension-permissive path [ "htm" "html" "xls" ] @ext)
                        (if (= @ext "htm")
                        then    (set @ext "html") ))
                (seq    (search case "XML" m)
                        (search case "document" m)
                        (search case "text" m)
                        (alt    (path-suggest-extension-permissive path [ "svg" "opf" ] @ext)
                                (set @ext "xml") ))
                (seq    (search case "lyx " m)
                        (search case "text" m)
                        (set @ext "lyx") )
                (seq    (search case "python" m)
                        (search case "text" m)
                        (search case "executable" m)
                        (set @ext "py") )
                (seq    (search case "SubRip" m)
                        (search case "text" m)
                        (set @ext "srt") )
                (seq    (search case "SQLite" m)
                        (alt    (path-suggest-extension-permissive path [ "cfg" ] @ext)
                                (set @ext "db") ))
                (seq    (search case "ext2 filesystem data" m)
                        (set @ext "ext2") )
                (seq    (search case "ISO 9660 CD-ROM filesystem data" m)
                        (set @ext "iso") )
                (seq    (search case "UDF filesystem data" m)
                        (set @ext "iso") )
                (seq    (search case "PE32 executable" m)
                        (search case "MS Windows" m)
                        (alt    (seq    (search case "(dll)" m)
                                        (set @ext "dll") )
                                (set @ext "exe") ))
                (seq    (search case " text" m)
                        (alt    (seq    (= (path-extension path) "")
                                        (set @ext "") )
                                (path-suggest-extension-permissive path
                                        [ "txt" "cue" "log" "srt" "vtt" "bat" "avs" "mfl" "pgn" "fen"
                                          "c" "h" "cpp" "cc" "pas" "hs" "go" "clp" "l" "ss"
                                          "java" "sh" "dot" ] @ext )))
                (seq    (= m "data")
                        (rmatch case path ".ts")
                        (set @ext "ts") )))

(defnet path-suggest-extension-permissive (path ext-l @ext)
        (deflocal found)
        (set found false)
        (for @ext in ext-l do
                (set found (rmatch case path (+ "." @ext)))
                until found )
        (truep found) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;                                                                      ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

